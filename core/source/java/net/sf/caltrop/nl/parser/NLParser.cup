/* 
BEGINCOPYRIGHT X
	
	Copyright (c) 2007, Xilinx Inc.
	All rights reserved.
	
	Redistribution and use in source and binary forms, 
	with or without modification, are permitted provided 
	that the following conditions are met:
	- Redistributions of source code must retain the above 
	  copyright notice, this list of conditions and the 
	  following disclaimer.
	- Redistributions in binary form must reproduce the 
	  above copyright notice, this list of conditions and 
	  the following disclaimer in the documentation and/or 
	  other materials provided with the distribution.
	- Neither the name of the copyright holder nor the names 
	  of its contributors may be used to endorse or promote 
	  products derived from this software without specific 
	  prior written permission.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
	CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
	CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
	NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	
ENDCOPYRIGHT
*/


package net.sf.caltrop.nl.parser;

import java_cup.runtime.*;
import org.w3c.dom.*;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.util.*;
import net.sf.caltrop.util.source.ParserErrorException;
import net.sf.caltrop.util.source.GenericError;


/*--INSERT-IMPORTS--*/

//////////////////////////////////////////////////////////////////////////
//// Caltrop parser
// {Build as "java -classpath "../.." java_cup.Main -parser Parser -symbols Terminal NLParser.cup").

//
//  Extend action class with utilities
//
action code {:
    private Element appendChild(Element element, Node child1) {
        if (child1 != null)
            element.appendChild(child1);
        return element;
    }
    private Element appendChild(Element element, Node child1, Node child2) {
        if (child1 != null)
            element.appendChild(child1);
        if (child2 != null)
            element.appendChild(child2);
        return element;
    }
    private Element appendChild(Element element, Node child1, Node child2, Node child3) {
        if (child1 != null)
            element.appendChild(child1);
        if (child2 != null)
            element.appendChild(child2);
        if (child3 != null)
            element.appendChild(child3);
        return element;
    }
    private Element appendChildren(Element element, List children) {
        if (children != null) {
            if (parser.getDebug())
                System.out.println("Append to node." + (element != null ? element.getNodeName() : "-nil-"));
            for (Iterator it = children.iterator(); it.hasNext(); ) {
                Node aNode = (Node)it.next();
                if (aNode != null) {
                    if (parser.getDebug())
                        System.out.println("   node." + aNode.getNodeName());
                    if (aNode instanceof Attr)
                        element.setAttributeNode((Attr)aNode);
                    else
                        element.appendChild(aNode);
                }
            }
        }
        return element;
    }
    private Attr createAttribute(String name) {
        return parser.getDocument().createAttribute(name);
    }
    private Element createElement(String name) {
        return parser.getDocument().createElement(name);
    }
    private Element createElement(String name, String kind) {
        Element element = parser.getDocument().createElement(name);
        element.setAttribute("kind", kind);
        return element;
    }
    private void addTextRange(Element e, int s1left, int s1right, int s2left, int s2right) {
    	try {
			e.setAttribute("text-begin-line", Integer.toString(s1left));
			e.setAttribute("text-begin-col", Integer.toString(s1right));
			e.setAttribute("text-end-line", Integer.toString(s2left));
			e.setAttribute("text-end-col", Integer.toString(s2right));
		} catch (Exception exc) {
			exc.printStackTrace();
			throw new NLParserException(exc.getMessage());
		}
    }
    private void error(String message) {
        parser.report_error(message);
    }
    private void error(String aMessage, String constructName, int lineNumber, int colNumber) {
        parser.report_error(aMessage, null, " in \"" + constructName + "\" construct starting at line " + lineNumber + "." + colNumber + ".");
    }
//    private Document getDocument() {
//        return parser.getDocument();
//    }
    private Element getDocumentElement() {
        return parser.getDocument().getDocumentElement();
    }
    private Element setAttribute(Element element, String name, String value) {
        if ((name != null) && (value != null)) element.setAttribute(name, value);
        return element;
    }
    private Element setName(Element element, String value) {
        if (value != null) element.setAttribute("name", value);
        return element;
    }
    /*--INSERT-ACTION-CODE--*/
:}

//
//  Extend action class with main program and parser.
//
parser code {:

    ///////////////////////////////////////////////////////////////////////
    ////  Network
    ///////////////////////////////////////////////////////////////////////

    //
    //  Return a document containing the parsed lexer source, describing the source as 'fileName' in diagnostics.
    //
    public Document parseNetwork() throws ParserErrorException {
        return parseNetwork("<nofile>");
    }

    public Document parseNetwork(String filename) throws ParserErrorException {
        return parseNetwork(filename, false);
    }

    //
    //  Return a document containing the parsed lexer source, describing the source as 'fileName' in diagnostics.
    //
    public Document parseNetwork(String filename, boolean doDebug) throws ParserErrorException
    {
        net.sf.caltrop.util.xml.Util.setDefaultDBFI();
        DOMImplementation domImpl = null;
        try
        {
          domImpl = DocumentBuilderFactory.newInstance().newDocumentBuilder().getDOMImplementation();
        } catch (ParserConfigurationException pce)
        {
          throw new NLParserException(pce.getMessage());
        }

        document = domImpl.createDocument("", "Network", null);
        file = filename;
        debug = doDebug;
        //this.errors = 0;
        this.errorList = new ArrayList();
        document.insertBefore(document.createComment(" Generated by Caltrop Parser version 1.2 "), document.getDocumentElement());
        //Symbol returnSymbol = debug ? super.debug_parse() : super.parse();
        Symbol returnSymbol = null;
        try
        {
            returnSymbol = debug ? super.debug_parse() : super.parse();
        } catch (Exception e)
        {
            if (this.errorList.isEmpty())
                throw new NLParserException(e.getMessage());
            else 
                throw new ParserErrorException("Errors found in parsing CAL source", this.errorList);
        }
        
        //if (this.errors > 0)
        if (!this.errorList.isEmpty())
        {
            throw new ParserErrorException("Errors found in parsing CAL source", this.errorList);
        }
        return returnSymbol != null ? document : null;
    }


    //
    //  Override the error report to prepend the sourece and line context.
    //
    public void report_error(String message) {
        if (debug && (lookahead != null)) {
            for (int i = 0; i <= lookahead_pos; i++) {
                System.out.println("Lookahead " + lookahead[i] + ", left=" + lookahead[i].left
                                + ", right=" + lookahead[i].right
                                + ", parse_state=" + lookahead[i].parse_state
                                + ", value=" + (lookahead[i].value != null ? lookahead[i].value : "-nil-"));
             }
        }
        report_error(message, lookahead != null ? lookahead[0] : cur_token);
    }

    //
    //  Override the error report to prepend the source and line context.
    //
    public void report_error(String message, Object info)
    {
        int line = -1;
        int col = -1;
        if (info instanceof Symbol)
        {
            line = ((Symbol)info).left;
            col = ((Symbol)info).right;
        }
        errorList.add(new GenericError(message, file, line, col));
    }

    //
    //  Generate a syntax error report describing 'aSymbol' with 'aMessage' suffix.
    //
    public void report_error(String messagePrefix, Symbol aSymbol, String messageSuffix) {
//        System.out.println("Symbol " + aSymbol + ", left=" + aSymbol.left
//                        + ", right=" + aSymbol.right
//                        + ", parse_state=" + aSymbol.parse_state
//                        + ", value=" + (aSymbol.value != null ? aSymbol.value : "-nil-"));
        Symbol theSymbol = aSymbol != null ? aSymbol : lookahead != null ? lookahead[0] : cur_token;
        String symValue = "<unknown>";
        if (theSymbol.value != null)
            symValue = theSymbol.value.toString();
        else if (theSymbol.sym == Terminal.EOF)
            symValue = "EOF";
        else
            symValue = "" + theSymbol.sym;
            
        report_error(messagePrefix + " \"" + symValue  +"\"" + messageSuffix, theSymbol);
    }

    //
    //  Override the symbol scan to report illegal characters and abort on error count exceeded..
    //
    public Symbol scan() throws ParserErrorException
    {
        while (true) {
            if (this.errorList.size() > max_errors)
            {
                throw new ParserErrorException("Too many errors.", this.errorList);
            }
            Symbol aSymbol = null;
            try
            {
              aSymbol = super.scan();
            } catch (Exception e)
            {
              throw new NLParserException(e.getMessage());
            }
            if (aSymbol == null)
                return null;
            if (debug)
                System.out.println("Scan symbol " + aSymbol + ", left=" + aSymbol.left
                            + ", right=" + aSymbol.right
                            + ", parse_state=" + aSymbol.parse_state
                            + ", value=" + (aSymbol.value != null ? aSymbol.value : "-nil-"));
            if (aSymbol.sym == Terminal.IllegalCharacter)
                report_error("Illegal character \"" + aSymbol.value  +"\".", aSymbol);
            else
                return aSymbol;
        }
    }

    //
    //  Generate a syntax error report on the current token with 'aMessage' suffix.
    //
    public void syntax_error(String aMessage) {
        if (debug && (lookahead != null)) {
            for (int i = 0; i <= lookahead_pos; i++) {
                System.out.println("Lookahead " + lookahead[i] + ", left=" + lookahead[i].left
                                + ", right=" + lookahead[i].right
                                + ", parse_state=" + lookahead[i].parse_state
                                + ", value=" + (lookahead[i].value != null ? lookahead[i].value : "-nil-"));
             }
        }
        syntax_error(lookahead != null ? lookahead[0] : cur_token, aMessage);
    }

    //
    //  Override the syntax error report to redirect to the symbol+message implementation.
    //
    public void syntax_error(Symbol aSymbol) {
        syntax_error(aSymbol, ".");
    }

    //
    //  Generate a syntax error report describing 'aSymbol' with 'messageSuffix'.
    //
    public void syntax_error(Symbol aSymbol, String messageSuffix) {
//        System.out.println("Symbol " + aSymbol + ", left=" + aSymbol.left
//                        + ", right=" + aSymbol.right
//                        + ", parse_state=" + aSymbol.parse_state
//                        + ", value=" + (aSymbol.value != null ? aSymbol.value : "-nil-"));

        String symValue = "<unknown>";
        if (aSymbol.value != null)
          symValue = aSymbol.value.toString();
        else if (aSymbol.sym == Terminal.EOF)
          symValue = "EOF";
        
        report_error("Syntax error near \"" + aSymbol.value  +"\"" + messageSuffix, aSymbol);
    }

    public boolean getDebug() { return debug; }
    public Document getDocument() { return document; }

    private boolean debug = false;          // True for debug messages.
    private Document document = null;       // Current document while reading.
    private String file = null;             // Name of source file in diagnostics
    private List<GenericError> errorList = new ArrayList();
    public int max_errors = 20;             // Maximum errors before termination.
    /*--INSERT-PARSER-CODE--*/
:}


terminal String IllegalCharacter;           // Used to propagate errors out from lexer to scan()..

terminal String Character;
terminal String Id;
terminal String Integer;
terminal String PartialOp;
terminal String Real;
terminal String String;
terminal String UnterminatedCharacter;
terminal String UnterminatedString;


terminal String NETWORK;
terminal String STRUCTURE;
terminal String ENTITY;
terminal String ENTITIES;
terminal String TYPE;

terminal String ACTION;
terminal String ACTOR;
terminal String ALL;
terminal String AND;
terminal String ANY;
terminal String ASSIGN;
terminal String ATN;
terminal String BEGIN;
terminal String CONST;
terminal String CHOOSE;
terminal String DEFAULT;
terminal String DIV;
terminal String DO;
terminal String DOM;
terminal String ELSE;
terminal String END;
terminal String END_ASSIGN;
terminal String END_BEGIN;
terminal String END_CHOOSE;
terminal String END_FOREACH;
terminal String END_FUNCTION;
terminal String END_IF;
terminal String END_INITIALIZE;
terminal String END_INVARIANT;
terminal String END_LAMBDA;
terminal String END_LET;
terminal String END_PRIORITY;
terminal String END_PROC;
terminal String END_PROCEDURE;
terminal String END_SCHEDULE;
terminal String END_WHILE;
terminal String ENSURE;
terminal String EQUALS_EQUALS_GT;
terminal String FALSE;
terminal String FOR;
terminal String FOREACH;
terminal String FUNCTION;
terminal String GUARD;
terminal String IF;
terminal String IMPORT;
terminal String IN;
terminal String INVARIANT;
terminal String LET;
terminal String LAMBDA;
terminal String MAP;
terminal String MOD;
terminal String MULTI;
terminal String MUTABLE;
terminal String NOT;
terminal String NULL;
terminal String OLD;
terminal String OR;
terminal String PACKAGE;
terminal String PROC;
terminal String PROCEDURE;
terminal String REPEAT;
terminal String SCHEDULE;
//terminal String TAIL;
terminal String THEN;
terminal String TO;
terminal String TRUE;
terminal String VAR;
terminal String WHILE;
//terminal String ZZZ;

terminal String COLON;
terminal String COLON_COLON;
terminal String COLON_EQUALS;
terminal String COMMA;
terminal String DASH_DASH_GT;
terminal String DASH_GT;
terminal String DOT;
terminal String DOTDOT;
terminal String EQUALS;
terminal String GT;
terminal String HASH;
terminal String LBRACE;
terminal String LBRACK;
terminal String LPAR;
terminal String LT;
terminal String PLUS;
terminal String QMARK;
terminal String RBRACE;
terminal String RBRACK;
terminal String RPAR;
terminal String SEMI;
terminal String STAR;
terminal String UNDER_SCORE;
terminal String VBAR;

/*--INSERT-TERMINALS--*/

non terminal Element network;
non terminal Element subnetwork;
non terminal List    network_body_things_opt;
non terminal List    network_body_things;
non terminal List    network_body_thing;
non terminal List    section_vars;
non terminal List    section_entities;
non terminal List    section_structure;

non terminal List    var_decls;
non terminal Element var_decl;

non terminal List    entity_decls_opt;
non terminal List    entity_decls;
non terminal Element entity_decl;
non terminal List    structure_stmts_opt;
non terminal List    structure_stmts;
non terminal Element structure_stmt;

non terminal Element structure_basic;
non terminal Element structure_cond;
non terminal Element structure_foreach;
non terminal Element connector;
non terminal Element port_ref;
non terminal Element entity_ref;
non terminal List    indices_opt;
non terminal List    indices;

non terminal List    dimensions_opt;
non terminal List    dimensions;
non terminal Element dimension;

non terminal Element entity_expr;
non terminal List    entity_exprs;

non terminal List    instantiation_args_opt;
non terminal List    instantiation_args_positional;
non terminal List    instantiation_args_named;

non terminal List    attributes_opt;
non terminal List    attributes;
non terminal Element attribute;

non terminal end_network;


non terminal Element body;
non terminal Element body_opt;
non terminal Element clause_default;
non terminal Element clause_guard;
non terminal Vector decl_generators;
non terminal Element decl_generator;
non terminal Element decl_input;
non terminal Vector decl_inputs;
non terminal Vector decl_parameters;
non terminal Vector decl_parameters_opt;
non terminal Element decl_parameter;
non terminal Element decl_parameter_head;
non terminal Vector decl_variables;
//non terminal Vector decl_variables_opt;
non terminal Element decl_variable;
non terminal Element decl_variable_function;
non terminal Element function_ret_type_opt;
non terminal Element decl_variable_procedure;
non terminal Element decl_variable_state;
non terminal Element decl_variable_state_head;
non terminal Element entry_tagged;
non terminal Vector entry_taggeds;
non terminal Vector entry_taggeds_opt;
non terminal Element entry_tagged_expr;
non terminal Element entry_tagged_type;
non terminal Vector entry_tagged_types;
non terminal Vector entry_tagged_types_opt;
non terminal Element entry_type;
non terminal Vector entry_types;
non terminal Vector entry_types_opt;
non terminal Element expr_binary;
non terminal Element expr_if;
non terminal Element expr_lambda;
non terminal Element expr_let;
non terminal Element expr_list;
non terminal Element expr_list_tail_opt;
non terminal Element expr_literal;
non terminal Element expr_map;
non terminal Element expr_postfix;
non terminal Element expr_primary;
non terminal Element expr_proc;
non terminal Element expr_set;
non terminal Element expr_tuple;
non terminal Element expr_tuple_tagged_head;
non terminal Element expr_unary;
non terminal Element expr_var;
non terminal Element expression;
non terminal Vector expressions;
non terminal Vector expressions_opt;
non terminal Element binary_expression_op;
non terminal Element unary_expression_op;
non terminal String expression_op_name;
non terminal Vector generators;
non terminal Element generator;
non terminal Element generator_in_opt;
non terminal Element guards_opt;
non terminal Vector imports;
non terminal Vector imports_opt;
non terminal Element import_;
non terminal String  import_kind;
non terminal Element mapping;
non terminal Vector mappings;
non terminal Element package_name_opt;
non terminal String package_name;
non terminal Element port_input;
non terminal Vector port_inputs;
non terminal Vector port_inputs_opt;
non terminal Element port_output;
non terminal Vector port_outputs;
non terminal Vector port_outputs_opt;
non terminal Element qid;
non terminal Vector qid_tail;
non terminal Element statement;
non terminal Vector statements;
non terminal Vector statements_opt;
non terminal Element stmt_assign;
non terminal Element stmt_assign_head;
non terminal Element stmt_block;
non terminal Element stmt_call;
non terminal Element stmt_choose;
non terminal Element stmt_foreach;
non terminal Element stmt_guarded;
non terminal Element stmt_guarded_head;
non terminal Element stmt_if;
non terminal Element stmt_while;
non terminal Element type_expr;
non terminal Element type_function;
non terminal Element type_list;
non terminal Element type_map;
non terminal Vector type_parameters;
non terminal Vector type_parameters_opt;
non terminal Element type_parameter;
non terminal Element type_parameter_id;
non terminal Element type_tuple;
non terminal Element type_unary;

non terminal Vector colon_generators_opt;
non terminal Vector var_decl_variables_opt;

non terminal String const_opt;
non terminal String do_opt;
non terminal Vector do_statements_opt;
non terminal end_assign;
non terminal end_begin;
non terminal end_choose;
non terminal end_foreach;
non terminal end_function;
non terminal end_if;
non terminal end_initialize;
non terminal end_invariant;
non terminal end_lambda;
non terminal end_let;
non terminal end_priority;
non terminal end_proc;
non terminal end_procedure;
non terminal end_schedule;
non terminal end_while;

non terminal String for_each;

non terminal String any_id;
non terminal String character;
non terminal String id;
non terminal String string;

non terminal String label_opt;
non terminal String multi_opt;
non terminal String semi_opt;

/*--INSERT-NON-TERMINALS--*/

terminal SHIFT_THERE;
//terminal REDUCE_HERE;

precedence nonassoc SHIFT_THERE;
/*--INSERT-LOWER-PRECEDENCE--*/
precedence nonassoc COMMA /*--INSERT-EQUAL-PRECEDENCE--*/;
/*--INSERT-HIGHER-PRECEDENCE--*/
//precedence nonassoc REDUCE_HERE;

/*--INSERT-START-PRODUCTION--*/

//
//  Network reader
//

network ::=
	NETWORK:aaa qid:name type_parameters_opt:typePars
	LPAR decl_parameters_opt:pars RPAR
	port_inputs_opt:iports EQUALS_EQUALS_GT port_outputs_opt:oports
	COLON
	
	network_body_things_opt:things
	
	end_network:zzz
	{:
		Element n = getDocumentElement();
		appendChild(n, name);
		appendChildren(n, iports);
		appendChildren(n, oports);
		appendChildren(n, typePars);
		appendChildren(n, pars);

		appendChildren(n, things);

        addTextRange(n, aaaleft, aaaright, zzzleft, zzzright);
        RESULT = n;
	:}
	;

network_body_things_opt ::=
	  /* EMPTY */ {: RESULT = null; :}
	| network_body_things:things {: RESULT = things; :}
	;
	
network_body_things ::=
	  network_body_thing:list 
	  {: List things = new ArrayList(); things.addAll(list); RESULT = things; :}
	| network_body_things:things network_body_thing:moreThings
	  {: things.addAll(moreThings); RESULT = things; :}
	;
	
network_body_thing ::=
	  import_:i {: RESULT = java.util.Collections.singletonList(i); :}
	| section_vars:varSection {: RESULT = varSection; :}
	| subnetwork:network {: RESULT = java.util.Collections.singletonList(network); :}
	| section_entities:entitySection {: RESULT = entitySection; :}
	| section_structure:structureSection {: RESULT = structureSection; :}
	;

section_vars ::=
	VAR var_decls:vars {: RESULT = vars; :}
    ;
    
var_decls ::= 
 	  var_decl:d 
 	  {: List ds = new ArrayList(); ds.add(d); RESULT= ds; :}
 	| var_decls:ds var_decl:d 
 	  {: ds.add(d); RESULT = ds; :}
 	;
 	
var_decl ::=
      decl_variable_state:d SEMI {: RESULT = d; :}
    | decl_variable_function:d {: RESULT = d; :}
    ;
        
subnetwork ::=
	NETWORK:aaa qid:name type_parameters_opt:typePars
	LPAR decl_parameters_opt:pars RPAR
	port_inputs_opt:iports EQUALS_EQUALS_GT port_outputs_opt:oports
	COLON
	
	network_body_things_opt:things
	
	end_network:zzz
	{:
		Element n = createElement("Network");
		appendChild(n, name);
		appendChildren(n, iports);
		appendChildren(n, oports);
		appendChildren(n, typePars);
		appendChildren(n, pars);

		appendChildren(n, things);

        addTextRange(n, aaaleft, aaaright, zzzleft, zzzright);
        RESULT = n;
	:}
	;


section_entities ::=
    ENTITIES entity_decls_opt:list {: RESULT = list; :}
    ;

entity_decls_opt ::=
      /* EMPTY */ {: RESULT = null; :}
    | entity_decls:list
      {: RESULT = list; :}
    ;
    
entity_decls ::=
      entity_decl:d 
      {: List list = new ArrayList(); list.add(d); RESULT = list; :}
    | entity_decls:list entity_decl:d 
      {: list.add(d); RESULT = list; :}
    ;
    
entity_decl ::=
	type_expr:et id:nm dimensions_opt:dims EQUALS entity_expr:ee SEMI
    {: 
        Element e = createElement("EntityDecl"); 
        setName(e, nm);
    	if (dims != null) {
    		Element d = createElement("Dimensions");
    		appendChildren(d, dims);
    		appendChild(e, d);
    	}
        appendChild(e, et, ee);
        RESULT = e;
    :}
	| id:nm dimensions_opt:dims EQUALS entity_expr:ee SEMI
    {: 
        Element e = createElement("EntityDecl"); 
        setName(e, nm);
    	if (dims != null) {
    		Element d = createElement("Dimensions");
    		appendChildren(d, dims);
    		appendChild(e, d);
    	}
        appendChild(e, ee);
        RESULT = e;
    :}
    ;
    
dimensions_opt ::= 
	  /* EMPTY */ {: RESULT = null; :}
	| dimensions:dims {: RESULT = dims; :}
	;
	
dimensions ::=
	  dimension:d
	  {: 
	  	  List dims = new ArrayList();
	  	  dims.add(d);
	  	  RESULT = dims;
	  :}
	| dimensions:dims dimension:d
	  {: dims.add(d); RESULT = dims; :}
	;
	
dimension ::=
	  LPAR RPAR
	  {: RESULT = createElement("Expr", "Undefined"); :}
	| LPAR expression:e RPAR
	  {: RESULT = e; :}
	;
	
entity_expr ::=
      id:nm LPAR instantiation_args_opt:args RPAR attributes_opt:attrs
      {: 
          Element e = createElement("EntityExpr", "Instantiation");
          setName(e, nm);
          appendChildren(e, args);
          appendChildren(e, attrs);
          RESULT = e;
      :}
    | IF expression:cond THEN entity_expr:e1 ELSE entity_expr:e2 end_if
      {:
          Element e = createElement("EntityExpr", "If");
          appendChild(e, cond, e1, e2);
          RESULT = e;
      :}
    | LBRACK entity_exprs:l colon_generators_opt:g RBRACK
      {:  
          Element e = createElement("EntityExpr", "List");
          appendChildren(e, l);
          appendChildren(e, g);
          RESULT = e; 
      :}
    ;
    
entity_exprs ::=
      entity_expr:e 
      {: List es = new ArrayList(); es.add(e); RESULT = es; :}
    | entity_exprs:es COMMA entity_expr:e
      {: es.add(e); RESULT = es; :}
    ;
    
instantiation_args_opt ::=
	  /* EMPTY */ {: RESULT = null; :}
	| instantiation_args_named:args {: RESULT = args; :}
	;
	
instantiation_args_named ::=
	  id:nm EQUALS expression:e 
	  {: 
	      List as = new ArrayList(); 
	      Element a = createElement("Arg");
	      setName(a, nm);
	      appendChild(a, e);
	      as.add(a); RESULT = as; 
	  :}
	| instantiation_args_named:as COMMA id:nm EQUALS expression:e
	  {: 
	      Element a = createElement("Arg");
	      setName(a, nm);
	      appendChild(a, e);
	      as.add(a); 
	      RESULT = as; 
	  :}
	;

section_structure ::=
    STRUCTURE structure_stmts_opt:list
    {: RESULT = list; :}
    ;
    
structure_stmts_opt ::=
	  /* EMPTY */ {: RESULT = null; :}
	| structure_stmts:list
	  {: RESULT = list; :}
	;

structure_stmts ::= 
      structure_stmt:s 
      {: List list = new ArrayList(); list.add(s); RESULT = list; :}
    | structure_stmts:list structure_stmt:s
      {: list.add(s); RESULT = list; :}
    ; 

structure_stmt ::=
	  structure_basic:s {: RESULT = s; :}
	| structure_cond:s {: RESULT = s; :}
	| structure_foreach:s {: RESULT = s; :}
	;
	
structure_basic ::=
    connector:src DASH_DASH_GT connector:dst attributes_opt:attrs SEMI
    {:
        Element e = createElement("StructureStmt", "Connection");
        appendChild(e, src, dst);
        appendChildren(e, attrs);
        RESULT = e;
    :}
    ;
    
connector ::= 
      port_ref:p
      {: 
         Element c = createElement("PortSpec", "Local");
         appendChild(c, p);
         RESULT = c;
      :}
    | entity_ref:e DOT port_ref:p
      {: 
         Element c = createElement("PortSpec", "Entity");
         appendChild(c, e, p);
         RESULT = c;
      :}
    ;
    
port_ref ::=
    id:nm indices_opt:idcs
    {: 
        Element e = createElement("PortRef");
        setName(e, nm);
        appendChildren(e, idcs);
      	RESULT = e;
    :}
    ;

entity_ref ::=
    id:nm indices_opt:idcs
    {: 
        Element e = createElement("EntityRef");
        setName(e, nm);
        appendChildren(e, idcs);
      	RESULT = e;
    :}
    ;

indices_opt ::=
	  /* EMPTY */ {: RESULT = null; :}
	| indices:idcs
	  {: RESULT = idcs; :}
	;
	
indices ::= 
      LBRACK expression:e RBRACK
      {: List idcs = new ArrayList(); idcs.add(e); RESULT = idcs; :}
    | indices:list LBRACK expression:e RBRACK
      {: list.add(e); RESULT = list; :}
    ;
    
attributes_opt ::=
      /* EMPTY */ {: RESULT = null; :}
    | LBRACE attributes:as RBRACE {: RESULT = as; :}
    ;
    
attributes ::=
      attribute:a 
      {: List as = new ArrayList(); as.add(a); RESULT = as; :}
    | attributes:as attribute:a
      {: as.add(a); RESULT = as; :}
    ;
    
attribute ::=
      id:nm EQUALS expression:val SEMI
      {: 
          Element attr = createElement("Attribute", "Value");
          setName(attr, nm);
          appendChild(attr, val);
          RESULT = attr;
      :}
    | id:nm COLON type_expr:t SEMI
      {: 
          Element attr = createElement("Attribute", "Type");
          setName(attr, nm);
          appendChild(attr, t);
          RESULT = attr;
      :}
    ;
    
structure_cond ::=
        IF expression:cond THEN structure_stmts_opt:stmtsThen end_if
        {:  
            Element s = createElement("StructureStmt", "If");
            appendChild(s, cond);
            Element s1 = createElement("StructureBlock", "Then");
            appendChildren(s1, stmtsThen);
            appendChild(s, s1);
            RESULT = s;
         :}
    |   IF expression:cond THEN structure_stmts_opt:stmtsThen ELSE structure_stmts_opt:stmtsElse end_if
        {:  
            Element s = createElement("StructureStmt", "If");
            appendChild(s, cond);
            Element s1 = createElement("StructureBlock", "Then");
            appendChildren(s1, stmtsThen);
            appendChild(s, s1);
            Element s2 = createElement("StructureBlock", "Else");
            appendChildren(s2, stmtsElse);
            appendChild(s, s2);
            RESULT = s;
         :}
	;
	
structure_foreach ::=
        generators:g DO structure_stmts:ss end_foreach 
        {:  
            Element s = createElement("StructureStmt", "Foreach");
            appendChildren(s, g);
            appendChildren(s, ss);
            RESULT = s; 
        :}
    ;



///////////////////////////////////////////////////






decl_generators ::=
        decl_generator:p
            {:  Vector list = new Vector(); list.add(p); RESULT = list; :}
    |   decl_generators:list COMMA decl_generator:p
            {:  list.add(p); RESULT = list; :}
    ;
decl_generator ::=
        id:i {: RESULT = setName(createElement("Decl", "Generator"), i); :}
    ;

decl_input ::=
        id:i {: RESULT = setName(createElement("Decl", "Input"), i); :}
    |   UNDER_SCORE:i {: RESULT = setName(createElement("Decl", "Input"), i); :}
    ;
decl_inputs ::=
        decl_input:p
            {:  Vector list = new Vector(); list.add(p); RESULT = list; :}
    |   decl_inputs:list COMMA decl_input:p
            {:  list.add(p); RESULT = list; :}
    ;

decl_parameters ::=
        decl_parameter:p
            {:  Vector list = new Vector(); list.add(p); RESULT = list; :}
    |   decl_parameters:list COMMA decl_parameter:p
            {:  list.add(p); RESULT = list; :}
    ;
decl_parameters_opt ::=
        /* empty */ {: RESULT = null; :}
    |   decl_parameters:list  {: RESULT = list; :}
    ;
decl_parameter ::=
        decl_parameter_head:p {: RESULT = p; :}
    |   decl_parameter_head:p EQUALS expression:e {: RESULT = appendChild(p, e); :}
    ;
decl_parameter_head ::=
        id:i
            {:  Element p = createElement("Decl", "Parameter");
                setName(p, i);
                RESULT = p; :}
    |   type_expr:t id:i
            {:  Element p = createElement("Decl", "Parameter");
                setName(p, i);
                appendChild(p, t);
                RESULT = p; :}
    ;

decl_variable ::=
        decl_variable_state:d {: RESULT = d; :}
    |   decl_variable_function:d {: RESULT = d; :}
    |   decl_variable_procedure:d {: RESULT = d; :}
    ;

decl_variables ::=
        decl_variable:p
            {:  Vector list = new Vector(); list.add(p); RESULT = list; :}
    |   decl_variables:list COMMA decl_variable:p
            {:  list.add(p); RESULT = list; :}
    ;

decl_variable_function ::=
        FUNCTION id:id LPAR decl_parameters_opt:p RPAR function_ret_type_opt:t
            var_decl_variables_opt:v /*ZZZ*/ COLON expression:e end_function
            {:  Element decl = createElement("Decl" , "Variable");
                Element type = createElement("Type", "Function");
                Element lambda = createElement("Expr", "Lambda");
                appendChild(decl, type, lambda);
                setName(decl, id);
                if (p != null) {
                    appendChildren(lambda, p);
          /*          for (Iterator pi = p.iterator(); pi.hasNext(); ) {
                        Element aParameter = (Element)pi.next();
                        NodeList type_list = aParameter.getElementsByTagName("Type");
                        int typeCount = type_list.getLength();
                        for (int i = 0; i < typeCount; i++) {
                            Element typeNode = (Element)type_list.item(i);
                            Element entry = createElement("Entry", "Type");
                            appendChild(entry, typeNode.cloneNode(true));
                            appendChild(type, entry);
                        }
                    }   */
                }
                appendChild(lambda, t);  // may be null, then nothing happens.
           //     appendChild(type, (t == null) ? null : t.cloneNode(true));
                setAttribute(type, "infer", "true");
                appendChildren(lambda, v);
                appendChild(lambda, e);
                RESULT = decl; :}
    |   FUNCTION:k error end_function {: error("Illegal function declaration.", k, kleft, kright); RESULT = null; :}
    ;

function_ret_type_opt ::=
        /* empty */ {: RESULT = null; :}
    |   DASH_DASH_GT type_expr:t
        {: RESULT = t; :}
    ;

decl_variable_procedure ::=
        PROCEDURE id:id LPAR decl_parameters_opt:p RPAR
            var_decl_variables_opt:v BEGIN statements:s end_procedure
            {:  Element decl = createElement("Decl" , "Variable");
                Element type = createElement("Type", "Procedure" );
                Element proc = createElement("Expr", "Proc");
                appendChild(decl, type, proc);
                setName(decl, id);
                if (p != null) {
                    appendChildren(proc, p);
             /*       for (Iterator pi = p.iterator(); pi.hasNext(); ) {
                        Element aParameter = (Element)pi.next();
                        NodeList type_list = aParameter.getElementsByTagName("Type");
                        int typeCount = type_list.getLength();
                        for (int i = 0; i < typeCount; i++) {
                            Element typeNode = (Element)type_list.item(i);
                            Element entry = createElement("Entry", "Type");
                            appendChild(entry, typeNode.cloneNode(true));
                            appendChild(type, entry);
                        }
                    } */
                }
                setAttribute(type, "infer", "true");
                appendChildren(proc, v);
                appendChildren(proc, s);
                RESULT = decl; :}
    |   PROCEDURE:k error end_procedure {: error("Illegal procedure declaration.", k, kleft, kright); RESULT = null; :}
    ;

decl_variable_state ::=
        decl_variable_state_head:d
            {: setAttribute(d, "assignable", "Yes"); RESULT = d; :}
    |   decl_variable_state_head:d COLON_EQUALS expression:e
            {: setAttribute(d, "assignable", "Yes"); RESULT = appendChild(d, e); :}
    |   decl_variable_state_head:d EQUALS expression:e
            {: RESULT = appendChild(d, e); :}
    |   MUTABLE decl_variable_state_head:d EQUALS expression:e
            {: setAttribute(d, "mutable", "Yes"); RESULT = appendChild(d, e); :}
    ;
decl_variable_state_head ::=
        id:i
            {:  Element decl = createElement("Decl" , "Variable");
                setName(decl, i);
                RESULT = decl; :}
    |   type_expr:t id:i
            {:  Element decl = createElement("Decl" , "Variable");
                setName(decl, i);
                RESULT = appendChild(decl, t); :}
    ;


entry_tagged ::=
        id:id COLON type_expr:type
            {:  Element option = createElement("Entry", "Type");
                setName(option, id);
                RESULT = appendChild(option, type); :}
    |   id:id EQUALS expression:e
            {:  Element option = createElement("Entry", "Expr");
                setName(option, id);
                RESULT = appendChild(option, e); :}
    ;
entry_taggeds ::=
        entry_tagged:p
            {:  Vector list = new Vector(); list.add(p); RESULT = list; :}
    |   entry_taggeds:list COMMA entry_tagged:p
            {:  list.add(p); RESULT = list; :}
    ;
entry_taggeds_opt ::=
        /* empty */ {: RESULT = null; :}
    |   entry_taggeds:list  {: RESULT = list; :}
    ;

entry_tagged_expr ::=
        id:id EQUALS expression:e
            {:  Element option = createElement("Entry", "Expr");
                setName(option, id);
                RESULT = appendChild(option, e); :}
    ;

entry_tagged_type ::=
        id:id COLON type_expr:type
            {:  Element element = createElement("Entry", "Type");
                setName(element, id);
                RESULT = appendChild(element, type); :}
    ;
entry_tagged_types ::=
        entry_tagged_type:p
            {:  Vector list = new Vector(); list.add(p); RESULT = list; :}
    |   entry_tagged_types:list COMMA entry_tagged_type:p
            {:  list.add(p); RESULT = list; :}
    ;
entry_tagged_types_opt ::=
        /* empty */ {: RESULT = null; :}
    |   entry_tagged_types:list  {: RESULT = list; :}
    ;

entry_type ::=
        type_expr:type {: RESULT = appendChild(createElement("Entry", "Type"), type); :}
    ;
entry_types ::=
        entry_type:p
            {:  Vector list = new Vector(); list.add(p); RESULT = list; :}
    |   entry_types:list COMMA entry_type:p
            {:  list.add(p); RESULT = list; :}
    ;
entry_types_opt ::=
        /* empty */ {: RESULT = null; :}
    |   entry_types:list  {: RESULT = list; :}
    ;

expression ::=
        expr_unary:e {: RESULT = e; :}
    |   expr_binary:e {: RESULT = e; :}
    ;
expressions ::=
        expression:e {:  Vector list = new Vector(); list.add(e); RESULT = list; :}
    |   expressions:list COMMA expression:e {: list.add(e); RESULT = list; :}
    ;
expressions_opt ::=
        /* empty */ {: RESULT = null; :}
    |   expressions:list {: RESULT = list; :}
    ;

expr_binary ::=
        expr_unary:e1 binary_expression_op:o expr_unary:e2
            {: RESULT = appendChild(createElement("Expr", "BinOpSeq"), e1, o, e2); :}
    |   expr_binary:e binary_expression_op:o expr_unary:e2
            {: RESULT = appendChild(e, o, e2); :}
    ;

expr_if ::=
        IF expression:i THEN expression:t ELSE expression:f end_if
            {: RESULT = appendChild(createElement("Expr", "If"), i, t, f); :}
    |   IF:k error end_if {: error("Illegal if expression.", k, kleft, kright); RESULT = null; :}
    ;

expr_lambda ::=
        const_opt:c LAMBDA LPAR decl_parameters_opt:d RPAR function_ret_type_opt:t
            var_decl_variables_opt:v /*ZZZ*/ COLON expression:b end_lambda
            {:  Element e = createElement("Expr", "Lambda");
                if (c != null) setAttribute(e, "const", "Yes");
                appendChildren(e, d);
                appendChild(e, t);
                appendChildren(e, v);
                RESULT = appendChild(e, b); :}
//    |   LAMBDA:k error end_lambda {: error("Illegal lambda expression.", k, kleft, kright); RESULT = null; :}
    ;

expr_let ::=
        LET decl_variables:v /*ZZZ*/ COLON expression:b end_let
            {:  Element e = createElement("Expr", "Let");
                appendChildren(e, v);
                RESULT = appendChild(e, b); :}
    |   LET:k error end_let {: error("Illegal let expression.", k, kleft, kright); RESULT = null; :}
    ;

expr_list ::=
        LBRACK RBRACK {: RESULT = createElement("Expr", "List"); :}
     |  LBRACK expressions:l colon_generators_opt:g  RBRACK
            {:  Element e = createElement("Expr", "List");
                appendChildren(e, l);
                RESULT = appendChildren(e, g);
             :}
    ;

expr_literal ::=
        character:v
            {:  Element e = createElement("Expr", "Literal");
                setAttribute(e, "literal-kind", "Character");
                RESULT = setAttribute(e, "value", v); :}
    |   FALSE
            {:  Element e = createElement("Expr", "Literal");
                setAttribute(e, "literal-kind", "Boolean");
                RESULT = setAttribute(e, "value", "0"); :}
    |   Integer:v
            {:  Element e = createElement("Expr", "Literal");
                setAttribute(e, "literal-kind", "Integer");
                RESULT = setAttribute(e, "value", v); :}
    |   NULL
            {:  RESULT = setAttribute(createElement("Expr", "Literal"), "literal-kind", "Null"); :}
    |   Real:v
            {:  Element e = createElement("Expr", "Literal");
                setAttribute(e, "literal-kind", "Real");
                RESULT = setAttribute(e, "value", v); :}
    |   string:v
            {:  Element e = createElement("Expr", "Literal");
                setAttribute(e, "literal-kind", "String");
                RESULT = setAttribute(e, "value", v); :}
    |   TRUE
            {:  Element e = createElement("Expr", "Literal");
                setAttribute(e, "literal-kind", "Boolean");
                RESULT = setAttribute(e, "value", "1"); :}
    ;

expr_map ::=
        MAP LBRACE RBRACE {: RESULT = createElement("Expr", "Map"); :}
    |   MAP LBRACE mappings:m colon_generators_opt:g RBRACE
            {: RESULT = appendChildren(appendChildren(createElement("Expr", "Map"), m), g); :}
    ;

expr_postfix ::=
        expr_primary:e {: RESULT = e; :}
    |   expr_postfix:c LPAR expressions_opt:i RPAR
            {:  Element e = appendChild(createElement("Expr", "Application"), c);
                RESULT = appendChild(e, appendChildren(createElement("Args"), i)); :}
    |   expr_postfix:c LBRACK expressions_opt:i RBRACK
            {:  Element e = appendChild(createElement("Expr", "Indexer"), c);
                RESULT = appendChild(e, appendChildren(createElement("Args"), i)); :}
    |   expr_postfix:c DOT id:id {: RESULT = appendChild(setName(createElement("Expr", "Entry"), id), c); :}
    ;

expr_primary ::=
        expr_var:e {: RESULT = e; :}
    |   expr_literal:e {: RESULT = e; :}
    |   expr_if:e {: RESULT = e; :}
    |   expr_lambda:e {: RESULT = e; :}
    |   expr_proc:e {: RESULT = e; :}
    |   expr_let:e {: RESULT = e; :}
//    |   expr_tuple:e {: RESULT = e; :}
    |   expr_list:e {: RESULT = e; :}
    |   expr_set:e {: RESULT = e; :}
    |   expr_map:e {: RESULT = e; :}
    |   LPAR expression:e RPAR {: RESULT = e; :}
    ;

expr_proc ::=
        PROC LPAR decl_parameters_opt:d RPAR var_decl_variables_opt:v BEGIN statements:s end_proc
            {:  Element e = createElement("Expr", "Proc");
                appendChildren(e, d);
                appendChildren(e, v);
                appendChildren(e, s);
                RESULT = e; :}
    |   PROC:k error end_procedure {: error("Illegal proc expression.", k, kleft, kright); RESULT = null; :}
    ;

expr_set ::=
        LBRACE RBRACE {: RESULT = createElement("Expr", "Set"); :}
    |   LBRACE expressions:m colon_generators_opt:g RBRACE
            {:  Element e = createElement("Expr", "Set");
                appendChildren(e, m);
                appendChildren(e, g);
                RESULT = e; :}
    ;

/*expr_tuple ::=
        LPAR RPAR
            {:  RESULT = createElement("Expr", "TaggedTuple"); :}
    |   expr_tuple_tagged_head:e RPAR
            {:  RESULT = e; :}
    ;
expr_tuple_tagged_head ::=
        LPAR entry_tagged_expr:e {: RESULT = appendChild(createElement("Expr", "TaggedTuple"), e); :}
    |   expr_tuple_tagged_head:tuple COMMA entry_tagged_expr:e  {: RESULT = appendChild(tuple, e); :}
    ;
*/
expr_unary ::=
        expr_postfix:e {: RESULT = e; :}
    |   unary_expression_op:o expr_postfix:e
            {: RESULT = appendChild(createElement("Expr", "UnaryOp"), o, e); :}
    ;

expr_var ::=
        id:id {: RESULT = setName(createElement("Expr", "Var"), id); :}
    |   OLD id:id
            {:  Element e = createElement("Expr", "Var");
                setName(e, id);
                RESULT = setAttribute(e, "old", "Yes"); :}
    ;

generator ::=
        for_each decl_generators:g generator_in_opt:i
            {:  Element element = createElement("Generator");
                appendChildren(element, g);
                RESULT = appendChild(element, i); :}
    |   for_each type_expr:type decl_generators:g generator_in_opt:i
            {:  Element element = createElement("Generator");
                appendChild(element, type);
                appendChildren(element, g);
                RESULT = appendChild(element, i); :}
    ;
generators ::=
        generator:e {:  Vector list = new Vector(); list.add(e); RESULT = list; :}
    |   generators:list COMMA expression:e
            {:  Element generator = (Element)list.get(list.size()-1);
                NodeList filtList = generator.getElementsByTagName("Filters");
                if ((filtList == null) || (filtList.getLength() <= 0))
                    appendChild(generator, appendChild(createElement("Filters"), e));
                else
                    appendChild((Element)filtList.item(filtList.getLength()-1), e);
                RESULT = list; :}
    |   generators:list COMMA generator:e {: list.add(e); RESULT = list; :}
    ;
generator_in_opt ::=
        /* empty */ {: RESULT = null; :} %prec SHIFT_THERE
    |   IN expression:e {: RESULT = e; :}
    ;

guards_opt ::=
        /* empty */ {: RESULT = null; :}
    |   GUARD expressions:e {: RESULT = appendChildren(createElement("Guards"), e); :}
    ;

imports ::=
        import_:e {:  Vector list = new Vector(); list.add(e); RESULT = list; :}
    |   imports:list import_:e {:  list.add(e); RESULT = list; :}
    ;
imports_opt ::=
        /* empty */ {:  RESULT = null; :}
    |   imports:list {:  RESULT = list; :}
    ;

import_ ::=
        IMPORT import_kind:kind ALL qid:i SEMI
            {:  Element element = createElement("Import");
                setAttribute(element, "kind", "package");
                setAttribute(element, "namespace", kind);
                RESULT = appendChild(element, i); :}
    |   IMPORT import_kind:kind qid:i SEMI
            {:  Element element = createElement("Import");
                setAttribute(element, "kind", "single");
                setAttribute(element, "namespace", kind);
                RESULT = appendChild(element, i); :}
    |   IMPORT import_kind:kind qid:i EQUALS id:name SEMI
            {:  Element element = createElement("Import");
                setAttribute(element, "kind", "single");
                setAttribute(element, "alias", name);
                setAttribute(element, "namespace", kind);
                RESULT = appendChild(element, i); :}
    |   IMPORT:k error SEMI {: error("Illegal import declaration.", k, kleft, kright); RESULT = null; :}
    ;

import_kind ::= 
      /* EMPTY */  {: RESULT = "Variable"; :}
    | VAR  {: RESULT = "Variable"; :}
    | TYPE {: RESULT = "Type"; :}
    | ENTITY {: RESULT = "Entity"; :}
    ;

mapping ::=
        expression:e1 DASH_GT expression:e2
            {: RESULT = appendChild(createElement("Mapping"), e1, e2); :}
    ;
mappings ::=
        mapping:e {:  Vector list = new Vector(); list.add(e); RESULT = list; :}
    |   mappings:list COMMA mapping:e {:  list.add(e); RESULT = list; :}
    ;


port_input ::=
        multi_opt:m id:i
            {:  Element port = createElement("Port", "Input");
                setName(port, i);
                if (m != null) setAttribute(port, "multi", "Yes");
                RESULT = port; :}
    |   multi_opt:m type_expr:t id:i
            {:  Element port = createElement("Port", "Input");
                setName(port, i);
                if (m != null) setAttribute(port, "multi", "Yes");
                appendChild(port, t);
                RESULT = port; :}
    ;
port_inputs ::=
        port_input:port {:  Vector list = new Vector(); list.add(port); RESULT = list; :}
    |   port_inputs:list COMMA port_input:port {:  list.add(port); RESULT = list; :}
    ;
port_inputs_opt ::=
        /* empty */ {:  RESULT = null; :}
    |   port_inputs:list {:  RESULT = list; :}
    ;

port_output ::=
        multi_opt:m id:i
            {:  Element port = createElement("Port", "Output");
                setName(port, i);
                if (m != null) setAttribute(port, "multi", "Yes");
                RESULT = port; :}
    |   multi_opt:m type_expr:t id:i
            {:  Element port = createElement("Port", "Output");
                setName(port, i);
                if (m != null) setAttribute(port, "multi", "Yes");
                appendChild(port, t);
                RESULT = port; :}
    ;
port_outputs ::=
        port_output:port {:  Vector list = new Vector(); list.add(port); RESULT = list; :}
    |   port_outputs:list COMMA port_output:port {:  list.add(port); RESULT = list; :}
    ;
port_outputs_opt ::=
        /* empty */ {:  RESULT = null; :}
    |   port_outputs:list {:  RESULT = list; :}
    ;


statement ::=
        SEMI {: RESULT = null; :}
    |   stmt_assign: s {: RESULT = s; :}
    |   stmt_call: s {: RESULT = s; :}
    |   stmt_choose: s {: RESULT = s; :}
    |   stmt_guarded: s {: RESULT = s; :}
    |   stmt_block: s {: RESULT = s; :}
    |   stmt_if: s {: RESULT = s; :}
    |   stmt_while: s {: RESULT = s; :}
    |   stmt_foreach: s {: RESULT = s; :}
    |   error SEMI {: error("Illegal statement."); RESULT = null; :}
    ;
statements ::=
        statement:e {:  Vector list = new Vector(); list.add(e); RESULT = list; :}
    |   statements:list statement:e {:  list.add(e); RESULT = list; :}
    ;
statements_opt ::=
        /* empty */ {:  RESULT = null; :}
    |   statements:list {:  RESULT = list; :}
    ;

stmt_assign ::=
        stmt_assign_head:statement COLON_EQUALS expression:e SEMI
            {:  RESULT = appendChild(statement, e); :}
    ;
stmt_assign_head ::=
        expr_primary:e
            {:  Element s = createElement("Stmt", "Assign");
                Attr name = e.getAttributeNode("name");
                if (name == null) {
                    error("Left-hand side of assignment must be name or indexed name.","",eleft,eright);
                    RESULT = appendChild(s, e);
                }
                else                                        // Preserved functionality
                    RESULT = setName(s, name.getValue()); :}
    |   expr_postfix:e LBRACK expressions_opt:i RBRACK
            {:  Element s = createElement("Stmt", "Assign");
                Element args = appendChildren(createElement("Args"), i);
                Attr name = e.getAttributeNode("name");
                if (name == null) {
                    error("Left-hand side of assignment must be name or indexed name.","",eleft,eright);
                    RESULT = appendChild(s, e);
                }
                else                               // Preserved functionality
                    RESULT = appendChild(setName(s, name.getValue()), args); :}
    |   expr_postfix:c DOT id:id
            {:  Element e = setName(createElement("Expr", "Entry"), id);
                RESULT = appendChild(createElement("Stmt", "Assign"), c, e); :}
    ;

stmt_choose ::=
        CHOOSE generators:g var_decl_variables_opt:v DO statements:s end_choose
            {:  Element statement = createElement("Stmt", "Choose");
                appendChildren(statement, g);
                Element body = createElement("Body");
                appendChildren(body, v);
                appendChildren(body, s);
                RESULT = appendChild(statement, body); :}
    |   CHOOSE:k error end_choose {: error("Illegal foreach statement.", k, kleft, kright); RESULT = null; :}
    ;

stmt_block ::=
        BEGIN var_decl_variables_opt:v DO statements:s end_begin
            {:  Element statement = createElement("Stmt", "Block");
                appendChildren(statement, v);
                appendChildren(statement, s);
                RESULT = statement; :}
    |   BEGIN statements:s end_begin
            {:  Element statement = createElement("Stmt", "Block");
                appendChildren(statement, s);
                RESULT = statement; :}
    |   BEGIN:k error end_begin {: error("Illegal block.", k, kleft, kright); RESULT = null; :}
    ;

stmt_call ::=
        expr_postfix:c LPAR expressions_opt:i RPAR SEMI
            {:  Element e = createElement("Stmt", "Call");
                Attr a = c.getAttributeNode("kind");
                if ((a != null) && a.getValue().equals("Tuple") && (c.getChildNodes().getLength() == 1))
                    appendChild(e, c.getFirstChild());            // Lose syntactical parentheses
                else
                    appendChild(e, c);
                RESULT = appendChild(e, appendChildren(createElement("Args"), i)); :}
    ;

stmt_foreach ::=
        generators:g var_decl_variables_opt:v DO statements:s end_foreach   // FIXME: par/seq
            {:  Element statement = createElement("Stmt", "Foreach");
                appendChildren(statement, g);
                Element body = createElement("Body");
                appendChildren(body, v);
                appendChildren(body, s);
                RESULT = appendChild(statement, body); :}
    |   for_each:k error end_foreach {: error("Illegal foreach statement.", k, kleft, kright); RESULT = null; :}
    ;

stmt_guarded ::=
        stmt_guarded_head:statement end_assign {: RESULT = statement; :}
    |   ASSIGN:k error end_assign {: error("Illegal guarded assignment statement.", k, kleft, kright); RESULT = null; :}
    ;
stmt_guarded_head ::=
        ASSIGN expressions:e TO
            {:  RESULT = appendChildren(createElement("Stmt", "Guarded"), e); :}
    |   stmt_guarded_head:statement clause_guard:clause
            {:  RESULT = appendChild(statement, clause); :}
    |   stmt_guarded_head:statement clause_default:clause
            {:  RESULT = appendChild(statement, clause); :}
    ;

stmt_if ::=
        IF expression:i THEN body:t end_if
            {:  RESULT = appendChild(createElement("Stmt", "If"), i, t); :}
    |   IF expression:i THEN body:t ELSE body:f end_if
            {:  RESULT = appendChild(createElement("Stmt", "If"), i, t, f); :}
//    |   IF:k error end_if {: error("Illegal if statement.", k, kleft, kright); RESULT = null; :}
    ;

stmt_while ::=
        WHILE expression:i var_decl_variables_opt:v DO statements_opt:s end_while
            {:  Element body = createElement("Stmt", "Block");
                appendChildren(body, v);
                appendChildren(body, s);
                RESULT = appendChild(createElement("Stmt", "While"), i, body); :}
    |   WHILE:k error end_while {: error("Illegal while statement.", k, kleft, kright); RESULT = null; :}
    ;

type_expr ::=
        type_function:type {: RESULT = type; :}
//    |   type_tuple:type {: RESULT = type; :}
//    |   type_list:type {: RESULT = type; :}
//    |   type_map:type {: RESULT = type; :}
    |   type_unary:type {: RESULT = type; :}
    ;

type_function ::=
        LBRACK entry_types_opt:e RBRACK
            {:  RESULT = appendChildren(createElement("Type", "Procedure" ), e); :}
    |   LBRACK entry_types_opt:e DASH_DASH_GT RBRACK
            {:  RESULT = appendChildren(createElement("Type", "Procedure"), e); :}
    |   LBRACK entry_types_opt:e DASH_DASH_GT type_expr:t RBRACK
            {:  RESULT = appendChild(appendChildren(createElement("Type", "Function"), e), t); :}
    ;

type_list ::=
        id:id LBRACK entry_types_opt:e RBRACK
            {:  Element type = createElement("Type" /*, "List" */);
                setName(type, id);
                RESULT = appendChildren(type, e); :}
    ;


type_parameters ::=
        type_parameter:e {:  Vector list = new Vector(); list.add(e); RESULT = list; :}
    |   type_parameters:list COMMA type_parameter:e {:  list.add(e); RESULT = list; :}
    ;
type_parameters_opt ::=
        /* empty */ {:  RESULT = null; :}
    |   LBRACK RBRACK {:  RESULT = null; :}
    |   LBRACK type_parameters:list RBRACK {:  RESULT = list; :}
    ;
type_parameter ::=
        type_parameter_id:i {:  RESULT = i; :}
    |   type_parameter_id:i LT type_expr:t {: RESULT = appendChild(i, t); :}
    ;
type_parameter_id ::=
        id:i {: RESULT = setName(createElement("TypeParameter"), i); :}
    ;

type_tuple ::=
        LPAR entry_tagged_types_opt:e RPAR
            {:  Element type = createElement("Type" /*, "Tuple" */);
                appendChildren(type, e);
                RESULT = type; :}
    ;

type_unary ::=
        id:id {: RESULT = setName(createElement("Type" /*, "Unary" */), id); :}
    ;


binary_expression_op ::=
        expression_op_name:op {: RESULT = setName(createElement("Op"), op); :}
//    |   COLON:k {: RESULT = setName(createElement("Op"), k);; :}
    ;
unary_expression_op ::=
        expression_op_name:op {: RESULT = setName(createElement("Op"), op); :}
    ;
expression_op_name ::=
        PartialOp:o {: RESULT = o; :}
    |   AND:k {: RESULT = k; :}
    |   DIV:k {: RESULT = k; :}
    |   DOM:k {: RESULT = k; :}
    |   DOTDOT:k {: RESULT = k; :}
    |   MOD:k {: RESULT = k; :}
    |   NOT:k {: RESULT = k; :}
    |   OR:k {: RESULT = k; :}
//    |   COLON:k {: RESULT = k; :}
//    |   DASH_GT:k {: RESULT = k; :}
    |   DASH_DASH_GT:k {: RESULT = k; :}
    |   EQUALS:k {: RESULT = k; :}
//    |   EQUALS_EQUALS_GT:k {: RESULT = k; :}
    |   HASH:k {: RESULT = k; :}
    |   LT:k {: RESULT = k; :}
    |   GT:k {: RESULT = k; :}
    |   PLUS:k {: RESULT = k; :}
    |   QMARK:k {: RESULT = k; :}
    |   STAR:k {: RESULT = k; :}
    |   VBAR:k {: RESULT = k; :}
    |   IllegalCharacter:k  {: RESULT = k; /* Never happens, but loses a warning */:}
    ;

character ::=
        Character:c {: RESULT = c; :}
    |   UnterminatedCharacter:c {: error("Unterminated character \'" + c + " .","",cleft,cright); RESULT = c; :}
    ;

id ::=
        Id:id {: RESULT = id; :}
//    |   AND:k {: RESULT = k; :}
//    |   DIV:k {: RESULT = k; :}
//    |   DOM:k {: RESULT = k; :}
//    |   MOD:k {: RESULT = k; :}
//    |   NOT:k {: RESULT = k; :}
//    |   OR:k {: RESULT = k; :}
    ;

qid ::=
     Id:id qid_tail:t
     {:
        Element qid = createElement("QID");
        Element e = createElement("ID");
        setName(e, id);
        appendChild(qid, e);
        String qs = id;
        for (int i = 0; i < t.size(); i++) {
            e = createElement("ID");
            String s = (String)t.get(i);
            setName(e, s);
            qs += "." + s;
            appendChild(qid, e);
        }
        setName(qid, qs);
        RESULT = qid;
     :}
     ;

qid_tail ::=
        /* empty */  {: RESULT = new Vector(); :}
    |   DOT id:i qid_tail:t
            {:
                t.add(0, i);
                RESULT = t;
            :}
     ;

string ::=
        String:c {: RESULT = c; :}
    |   UnterminatedString:c {: error("Unterminated string \"" + c + " .","",cleft,cright); RESULT = c; :}
    ;

colon_generators_opt ::=
        /* empty */ {: RESULT = null; :}
    |   COLON generators:g {: RESULT = g; :}
//    |   generators:g {: RESULT = g; :}
    ;

const_opt ::=
        /* empty */ {: RESULT = null; :}
    |   CONST:i {: RESULT = i; :}
    ;
do_opt ::=
        /* empty */ {: RESULT = null; :}
    |   DO:k {: RESULT = k; :}
    ;
do_statements_opt ::=
        /* empty */ {:  RESULT = null; :}
    |   DO statements:list {:  RESULT = list; :}
    ;

end_network ::= END;
end_assign ::= END | END_ASSIGN;
end_begin ::= END | END_BEGIN;
end_choose ::= END | END_CHOOSE;
end_foreach ::= END | END_FOREACH;
end_function ::= END | END_FUNCTION;
end_if ::= END | END_IF;
end_lambda ::= END | END_LAMBDA;
end_let ::= END | END_LET;
end_proc ::= END | END_PROC;
end_procedure ::= END | END_PROCEDURE;
end_while ::= END | END_WHILE;

for_each ::=
        FOR:k {: RESULT = k; :}
    |   FOREACH:k {: RESULT = k; :}
    ;
    
		
label_opt ::=
        /* empty */ {: RESULT = null; :}
    |   id:i COLON {: RESULT = i; :}
    ;
multi_opt ::=
        /* empty */ {: RESULT = null; :}
    |   MULTI:i {: RESULT = i; :}
    ;
semi_opt ::=
        /* empty */ {: RESULT = null; :}
    |   SEMI:i {: RESULT = i; :}
    ;

var_decl_variables_opt ::=
        /* empty */ {: RESULT = null; :}
    |   VAR decl_variables:list {: RESULT = list; :}
    ;

/*--INSERT-PRODUCTIONS--*/
