
/**
This actor implements a recursive filter that eliminates those
elements froma stream that satisfy a given relation with any
previous element of the stream that was *not* eliminated.

The standard use of this filter is the Sieve of Eratosthenes for
finding the prime numbers. In this case, the input stream must be the 
sequence of natural numbers (starting at 2), and the predicate is 
divisability of the first argument by the second:

 Sieve[Nat] ( lambda (Nat x, Nat y) --> Boolean : x mod y = 0 end )

@author JWJ
*/

actor Sieve [T] 
            ([T, T --> Boolean] pred) 

            T In ==> T Out:

  // Initialize the filter function to one that returns false:
  // the first token will always be let through.

  [T --> Boolean] filter := lambda (T a) --> Boolean : false end;


  // Simply remove the token if the filter function returns true.

  action [a] ==> [] guard filter(a) end


  // Let the token through if the filter function returns false.

  action [a] ==> [a] guard not filter(a) 
                     var [T --> Boolean] f = filter 
  do
    // After saving the current filter function in f, create a new filter
    // that is the logical or of the previous one, and an application of the
    // predicate with the current token as the second argument.

    filter := lambda(T b) --> Boolean: f(b) or pred(b,a) end;
  end

end

