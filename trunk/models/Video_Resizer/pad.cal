/* 
BEGINCOPYRIGHT X
	
	Copyright (c) 2004-2005, Xilinx Inc.
	All rights reserved.
	
	Redistribution and use in source and binary forms, 
	with or without modification, are permitted provided 
	that the following conditions are met:
	- Redistributions of source code must retain the above 
	  copyright notice, this list of conditions and the 
	  following disclaimer.
	- Redistributions in binary form must reproduce the 
	  above copyright notice, this list of conditions and 
	  the following disclaimer in the documentation and/or 
	  other materials provided with the distribution.
	- Neither the name of the copyright holder nor the names 
	  of its contributors may be used to endorse or promote 
	  products derived from this software without specific 
	  prior written permission.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
	CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
	CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
	NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	
ENDCOPYRIGHT
*/

// pad.cal
//
// Author: David B. Parlour (dave.parlour@xilinx.com)
//

actor pad
  (
    // Size of a pixel component
    int PIXSZ, 
    
    // Size of a coordinate (signed)  
    int COORDSZ,

    // Output image size
    int OWIDTH,
    int OHEIGHT
    
   )

      int(size=2*PIXSZ+1) IN, int(size=COORDSZ) NEXT ==> int(size=2*PIXSZ) OUT : 

  int FRAME_BIT =  1 << ( 2*PIXSZ );

  // If the incoming image does not fill the frame, then pad it out with a
  // border. This is a special code that tells the downstream PiP module
  // to use the corresponding pixel from the input image.  
  int BORDER = 0;
  
  // Make sure that a real pixel does not mimic the PiP special code.
  // Does not hurt to fiddle the "chroma" component if Y=0!
  function AVOID_RESERVED_VALUE( p ) :
    if p = 0 then 1 else p end
  end
  
  function isFramebit( p ) :
    ( p & FRAME_BIT ) != 0
  end
   
  function even( x ) :
    ( x & ( ~1 ) )
  end
   
  // This actor has the following contract with the cmdStuffer The cmdStuffer will always
  // emit the size to be used for the next frame each time it emits a start-of-frame token
  // for the current frame.
  
  // The pad actor will always emit a complete frame to the downstream actor.

  // Scan position
  int(size=COORDSZ) scan_x;
  int(size=COORDSZ) scan_y;
  int(size=COORDSZ) scan_width;
  int(size=COORDSZ) scan_height;
 
  // Display parameters
  int(size=COORDSZ) display_start_x;
  int(size=COORDSZ) display_start_y;
  int(size=COORDSZ) display_end_x;
  int(size=COORDSZ) display_end_y;
 
  // Input parameters
  int(size=COORDSZ) input_start_x;
  int(size=COORDSZ) input_start_y;
  int(size=COORDSZ) input_end_x;
  int(size=COORDSZ) input_end_y;

  // Get the parameters for the next frame
  width.pad: action NEXT:[ p ] ==>
  guard p < OWIDTH
  do
    // Display window is wider than input window
    scan_width      := OWIDTH;
    display_start_x := 0;
    display_end_x   := OWIDTH;
    input_start_x   := even( (OWIDTH  - p) >> 1 );
    input_end_x     := input_start_x + p;
  end

  width.crop: action NEXT:[ p ] ==>
  do
    // Display window is not as wide as input window
    scan_width      := p;
    display_start_x := even( (p - OWIDTH) >> 1 );
    display_end_x   := display_start_x + OWIDTH;
    input_start_x   := 0;
    input_end_x     := p;
  end

  height.pad: action NEXT:[ p ] ==> 
  guard p < OHEIGHT
  do
    // Display window is higher than input window
    scan_height     := OHEIGHT;
    display_start_y := 0;
    display_end_y   := OHEIGHT;
    input_start_y   := even( (OHEIGHT  - p) >> 1 );
    input_end_y     := input_start_y + p;
  end

  height.crop: action NEXT:[ p ] ==> 
  do
    // Display window is not as high as input window
    scan_height     := p;
    display_start_y := even( (p - OHEIGHT) >> 1 );
    display_end_y   := display_start_y + OHEIGHT;
    input_start_y   := 0;
    input_end_y     := p;
  end

  bool sof;
  bool next_sof := false;
  bool row_has_input;
  bool row_has_display;
  bool read;
  bool write;
  
  start: action ==>
  do
    scan_x          := 0;
    scan_y          := 0;
    sof             := next_sof;
    next_sof        := false;
    row_has_input   := scan_y >= input_start_y and scan_y < input_end_y;
    row_has_display := scan_y >= display_start_y and scan_y < display_end_y;
    read            := scan_x >= input_start_x and scan_x < input_end_x and row_has_input;
    write           := scan_x >= display_start_x and scan_x < display_end_x and row_has_display;
    //println("start read = " + read +", write = " + write);
    //println([input_start_x,input_start_y,input_end_x,input_end_y,display_start_x,display_start_y,display_end_x,display_end_y]);
  end
  
  eof: action ==>
  guard scan_y = scan_height
  end

  eol: action ==>
  guard scan_x = scan_width
  do
    scan_x          := 0;
    scan_y          := scan_y + 1;
    row_has_input   := scan_y >= input_start_y and scan_y < input_end_y;
    row_has_display := scan_y >= display_start_y and scan_y < display_end_y;
    read            := scan_x >= input_start_x and scan_x < input_end_x and row_has_input;
    write           := scan_x >= display_start_x and scan_x < display_end_x and row_has_display;
  end
 
 
   /*              
              Actions fireable in each condition ranked by priority (eol, eof are always enabled)
              
         write.read                                  sof.next_sof
                       
                                00                01               11               10
                            waiting for          can't           frame           frame in
                          frame to start        happen           ended           progress
        ========================================================================================
                                                          
            00                  X                 X                X                X
           can't
          happen

            
            01                 sof                X            increment           sof
         input win           consume                                              consume
          outside
          view win  


            11                 sof                X              border            sof
        input win and        consume                                               copy
         view overlap
                
        
            10                border              X              border          border
          view win
          outside
         input win
   
   
   */
   
  border: action ==> OUT:[ BORDER ]
  guard write and ( (not read) or next_sof )
  do
    scan_x := scan_x + 1;
    read   := scan_x >= input_start_x and scan_x < input_end_x and row_has_input;
    write  := scan_x >= display_start_x and scan_x < display_end_x and row_has_display;
  end

  increment: action ==>
  guard (not write) and sof and next_sof
  do
    scan_x := scan_x + 1;
    read   := scan_x >= input_start_x and scan_x < input_end_x and row_has_input;
    write  := scan_x >= display_start_x and scan_x < display_end_x and row_has_display;
  end

  sof: action IN:[ p ] ==>
  guard isFramebit( p ) and read and (not next_sof)
  do
    next_sof := sof;
    sof := true;
    // println("SOF in pad");
  end

  copy: action IN:[ p ] ==> OUT:[ AVOID_RESERVED_VALUE( p ) ]
  guard write and read and sof and (not next_sof)
  do
    scan_x := scan_x + 1;
    read   := scan_x >= input_start_x and scan_x < input_end_x and row_has_input;
    write  := scan_x >= display_start_x and scan_x < display_end_x and row_has_display;
  end    

  consume: action IN:[ p ] ==>
  guard read and (not next_sof) and ( (not sof) or (not write) )
  do
    scan_x := scan_x + 1;
    read   := scan_x >= input_start_x and scan_x < input_end_x and row_has_input;
    write  := scan_x >= display_start_x and scan_x < display_end_x and row_has_display;
  end    

  schedule fsm width :
    width   ( width    ) --> height;
    height  ( height   ) --> start;
    
    start   ( start    ) --> loop;
    
    loop   ( eof       ) --> width;
    loop   ( eol       ) --> loop;
    loop   ( border    ) --> loop;
    loop   ( increment ) --> loop;
    loop   ( sof       ) --> loop;
    loop   ( copy      ) --> loop;
    loop   ( consume   ) --> loop;
 
  end
  
  priority
    width.pad > width.crop;
    height.pad > height.crop;
    eof > eol > border > increment > sof > copy > consume;
  end
  
end