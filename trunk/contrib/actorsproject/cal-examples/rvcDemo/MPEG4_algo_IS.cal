// MPEG4_algo_IS.cal
//
// Author: David B. Parlour (dave.parlour@xilinx.com)
//
// Modified by: Carl von Platen (carl.von.platen@ericsson.com) 
//              Ericsson AB, 2009
//              Simplified using repeats and no read/write pipelining
//
// Copyright (c) 2004-2006 Xilinx Inc.
// All Rights Reserved
//
// Disclaimer:  THIS PROGRAM IS PROVIDED "AS IS" WITH NO WARRANTY 
//              WHATSOEVER AND XILINX SPECIFICALLY DISCLAIMS ANY 
//              IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
//              A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.

// Input :: Start --> values 0(zz scan),1(alt vert),2(alt horiz)
// Input :: QFS_AC  --> Ac coefficients in encoding order
// Output:: PQF_AC --> Ac coeffs in raster order
// Example 0,  1,  5,  6..... ==> 0, 1, 2, 3....

// Actors: 
// Skip --> No Start token
// Start -->     token on AC_PRED_DIR --> add_buf; InvScan mode received bofore AC coeffs
// read_only --> tokens on Ac --> buf ;fired only when the sample buffer is empty
// write_only -->Ac in buf --> PQF_AC in raster order; fired only when there are on fresh tokens on AC_PRED_DIR
// read_write -->tokens on QFS_AC --> buf ; AC coeffs in buf --> PQF_AC; fired only when buf is full and tokens are available on AC_PRED_DIR
// done --> done reading or writing or both (64 AC coeffs) --> fired when count is 64


import all caltrop.lib.BitOps;

actor MPEG4_algo_IS (int SAMPLE_SZ ) int(size=3) AC_PRED_DIR, int(size = SAMPLE_SZ) QFS_AC ==> int(size=SAMPLE_SZ) PQF_AC :

  List( type:int(size=7), size=192 ) Scanmode = 
  [    0,  1,  5,  6, 14, 15, 27, 28,  2,  4,  7, 13, 16, 26, 29, 42,	//0:63 zigzag
       3,  8, 12, 17, 25, 30, 41, 43,  9, 11, 18, 24, 31, 40, 44, 53,
      10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60,
      21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63,

       0,  4,  6, 20, 22, 36, 38, 52,  1,  5,  7, 21, 23, 37, 39, 53,	//64:127 Alt vert
       2,  8, 19, 24, 34, 40, 50, 54,  3,  9, 18, 25, 35, 41, 51, 55,
      10, 17, 26, 30, 42, 46, 56, 60, 11, 16, 27, 31, 43, 47, 57, 61,
      12, 15, 28, 32, 44, 48, 58, 62, 13, 14, 29, 33, 45, 49, 59, 63,

       0,  1,  2,  3, 10, 11, 12, 13,  4,  5,  8,  9, 17, 16, 15, 14,	//128:191 Alt Horiz
       6,  7, 19, 18, 26, 27, 28, 29, 20, 21, 24, 25, 30, 31, 32, 33,
      22, 23, 34, 35, 42, 43, 44, 45, 36, 37, 40, 41, 46, 47, 48, 49,
      38, 39, 50, 51, 56, 57, 58, 59, 52, 53, 54, 55, 60, 61, 62, 63
  ];

  skip: action AC_PRED_DIR:[ i ] ==>					
  guard i < 0						
  end							

  // AC_PRED_DIR=0 --> ZZ; 1-->Alternate Vertical; 2 --> Alternate Horiz

  rw: action AC_PRED_DIR:[ dir ], QFS_AC:[ac_in] repeat 63
                              ==> PQF_AC:[ ac_out ] repeat 63
  var
    int addr,
    int offset=lshift(dir,6)+1,
    List(type:int(size=SAMPLE_SZ), size=63) ac_out:=[0: for i in Integers(1,63)]
  do
    // ac_out = [ ac_in[Scanmode[offset+addr]-1] : for addr in Integers(0,62) ]
    addr:=0;
    while addr<63 do
      ac_out[addr]:=ac_in[ Scanmode[offset+addr]-1 ];
      addr:=addr+1;
    end
  end
 
  priority 
    skip > rw;
  end;

end