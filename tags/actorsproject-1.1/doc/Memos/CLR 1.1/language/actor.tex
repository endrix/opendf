


\chapter{Structure of actor descriptions}\label{chap:Actor}

\index{namespace!hierarchical}
\index{environment!global}
Each actor description defines a named {\em kind} of actor. Actors may
refer to entities defined in the implementation context, which
provides a hierarchical namespace for these entities, see section
\ref{sect:Imports} for details. Actor descriptions may use import
declarations to use parts of this namespace or the objects defined in
it as part of their global environment.


Actors are the largest lexical units of specification and translation.
The basic structure of an actor is this:

\index{actor@{\bf actor}}
\index{actor!structure of}
\index{:@{\tt :}!in actor head}
\index{<@{\tt <}!in type parameter constraint}
\index{time@\kwTime}
\index{==>@{\tt ==>}!in port declaration}
\index{=@{\tt =}!in actor parameters}
\index{multi@\kwMulti}
\index{end@\kwEnd}
\index{endactor@\kwEndActor}

\bgr
Actor : [Imports] \kwActor ~ID ;
    [ '['~TypePars~']' ]~'('~ActorPars~')'~IOSig ~[TimeClause]~'\charColon';
    \mul{VarDecl | Action | InitializationAction | PriorityBlock} ;
    [ActionSchedule] ;
    \mul{VarDecl | Action | InitializationAction | PriorityBlock} ;
    (\kwEnd|\kwEndActor).

TypePar : ID~ [ '\charLess'~ Type ] .

ActorPar : ~[Type]~ID~['='~Expression] .

IOSig : [PortDecls]~'==\charMore'~[PortDecls] .

PortDecl : [\kwMulti]~[Type]~ID .

TimeClause : \kwTime~ Type .
\egr

\index{actor!type parameter} \index{parameter!generic type}
\index{actor!parameter} \index{parameter!of actor}
\index{actor!port signature}
\index{port signature|see{actor, port signature}}
\index{action}
\index{initialization rule}
\index{priority block}
\index{action schedule}
The header of an actor contains optional type parameters and actor
parameters, and its port signature. This is followed by the body of the
actor, containing a sequence of state variable declarations (section
\ref{sect:VarDecls}), actions (chapter \ref{chap:Actions}),
initialization actions (section \ref{sect:InitActions}), priority blocks
(section \ref{sect:ActionPriorities}), and at most one action schedule
(section \ref{sect:ActionSchedules}).

\index{actor!type parameter}
\index{actor!type parameter!bound}
\index{parameter!generic type!bound}
\index{type bound|see{actor, type parameter, bound}}
Type parameters\sidenote{type parameters} are variable symbols that
are bound to types when the actor is instantiated. They can be used
like any other type inside the actor definition. Each type parameter
may be optionally {\em bounded},\sidenote{type bounds} i.e. they may
be associated with some type. In this case, the actual type that this
parameter is instantiated to is required to be a subtype of the bound
(including the bound itself).

\index{actor!parameter}
\index{parameter!of actor}
By contrast, actor parameters are {\em values}, i.e. concrete objects
of a certain type (although, of course, this type may be determined by
a type parameter).\sidenote{actor parameters} They are bound to identifiers which are visible
throughout the actor definition. Conceptually, these are
non-assignable and immutable, i.e. they may not be assigned to by an
actor. 

\index{implementation note!actor parameter}
\begin{implementation}
  A specific implementation such as the one in Ptolemy might change
  these parameters, for example in response to user interaction during
  design. For this to make sense in \Cal, the implementation has
  to ensure the consistency of the actor state with the new parameter
  values, which it usually does by reinitializing the actor whenever
  one of its parameters is assigned a new value.
\end{implementation}

\index{actor!port signature}
\index{channel}
\index{port!single}
\index{port!multiport}
\index{multiport|see{port, multiport}}
The port signature of an actor specifies the input ports and output ports,
including their names, whether the port is a multiport or a single
port, and the type of the tokens communicated via the
port. \sidenote{single ports vs. multiports} While
single ports represent exactly one sequence of input or output tokens,
multiports are comprised of any number of those sequences (called {\em
  channels}), including zero.


%The names of the ports are visible as variables inside the actor
%definition. If the token type of the port is $T$, the type of the port
%name is {\tt Port[T]} for single ports and {\tt MultiPort[T]} for
%multiports, respectively.  So an input port is really a mapping from
%channel identifiers to sequences of tokens.\footnote{Note that the
%  nature of channel identifiers is unspecified, and depends on the
%  environment. In order to be portable, actor descriptions should make
%  no assumptions about them other than that they are distinguishable
%  keys to channels.}  This makes all the usual facilities for maps
%available for dealing with ports: {\tt dom p} computes the set of
%channel identifiers defined for the port $p$, {\tt p[a]} is the
%channel of port $p$ identified by $a$.


\section{Namespaces and imports}\label{sect:Imports}

\index{namespace|(}
\index{import@{\bf import}|(}

\index{environment!global}
\index{variable!free}
An actor description may contain free variables, i.e. references to
variables not defined inside the actor. Often, these are functions or
procedures, but also types, which are predefined as part of the
respective implementation context. The collection of all globally
visible variable bindings is called the\sidenote{global environment}
{\em global environment} of an actor.

\index{namespace!hierarchical}
\index{identifier!qualified}
\index{qualified identifier|see{identifier, qualified}}
\index{importing!of binding}
However, implementation contexts may be very rich, providing a large
number of functions, procedures, and types for actor writers to use.
\sidenote{hierarchical context namespace}In such cases it would be
inappropriate to define all of these as global environment---it would
lead to a very large number of variable names, only a very small part
of which would actually be used by each actor definition. For this
reason, implementation contexts may use a hierarchical namespace for
naming these entities, where each entity is denoted by a sequence of
identifiers separated by dots (a so-called {\em qualified
  identifier}). Actor specifications may use them as part of their
global environment by {\em importing} them into it. \sidenote{imports
  assemble global environment}Effectively, one can think of import
declarations as constructing the global environment of an actor
description, starting with the default global environment, and adding
bindings to it.

\index{namespace!subnamespace}
\index{subnamespace}
\index{package|see{subnamespace}}
\index{local name}
\index{namespace!local name}
\sidenote{qualified id = subnamespace + local name}The qualified
identifiers that denote each entity in the hierarchical namespace have
two parts: the (possibly empty) sequence of identifiers up to and
excluding the last, and the last identifier. The first part is called
the {\em subnamespace} or {\em package}, while the second is called
the {\em local name}. For example, in the qualified identifiers {\tt
  X.Y.Z}, {\tt XYZ}, and {\tt java.util.HashMap}, the subnamespaces
are {\tt X.Y}, $\lambda$, and {\tt java.util},
respectively,\footnote{$\lambda$ denotes the empty sequence of
  identifiers.}  while the corresponding local names are {\tt Z}, {\tt
  XYZ}, and {\tt HashMap}.

\index{importing!single import}\index{single import}
\index{importing!group import}\index{group import}
\sidenote{single vs group imports}An import declaration can either
make a single entity available as the value of a global variable, or
the group of all entities inside the same subnamespace.

\bgr
Import : SingleImport | GroupImport '\charSemi' .

SingleImport : \kwImport~ QualID ~['=' ~ID] .

GroupImport : \kwImport ~\kwAll ~QualID .

QualID : ID ~\mul{\charDot ~ID} .
\egr

\index{importing!single import}\index{single import}
For a single import declaration, the qualified identifier denotes the
entity to be imported into the global environment. If the optional
identifier following it after an '=' is omitted, the entity denoted
by the qualified identifier is imported under its local name. 
For instance, the import declaration\\
{\tt import A.B.C;}\\
imports the entity denoted by {\tt A.B.C} under the name {\tt C} into
the global environment. If an identifier is specified, it will be the
name of the specified entity:\\
{\tt import A.B.C = D;}\\
imports the same entity under the name {\tt D}.

\index{importing!group import}\index{group import}
Group import declarations import entire groups of entities. In this
case, the qualified identifer specifies the subnamespace, and all
entities in that subnamespace are imported under their local
names. For example,\\
{\tt import all A.B;}\\
imports {\tt A.B.C} as {\tt C} and {\tt A.B.E} as {\tt E}, if these
are the two entities in that subnamespace.

\index{namespace|)}
\index{import@{\bf import}|)}

\section{Time}\label{sect:Time}

\index{time|(}
\index{delay|(}
\index{time system|(}

\index{action!duration}
\index{firing!duration}
\index{duration!of action firing}

\sidenote{time semantics external to actor}\Cal supports an abstract
notion of {\em time} as a way to relate the ``duration'' of various
actor firings to each other, and thus potentially control or constrain
the concurrency in a model that consists of several actors. It is
essential to the division of responsibility between an actor and its
environment that the actor itself does not interpret this time
information, as it impacts the coordination of more than one actor,
rather than the execution of an isolated actor. For this reason, time
is purely declarative in \Cal, and the language itself does not attach
any meaning to it whatsoever, other than it being a property of actor
transitions.

\index{time!tag}
\index{tag!in time system}
\index{time!delay}
\index{delay!in time system}
\index{order!of time tags}
\index{time!tag!order}
\index{tag!in time system!order}
\index{time!adding delays}
\index{time!delay!zero}
\index{delay!in time system!zero}
\index{zero delay!in time system}

The\sidenote{time system: \\tags,
  delays, addition, zero delay} {\em time
  system} of an actor is an algebraic structure that has
\begin{itemize}
\item a set of {\em time tags}
\item a set of {\em time delays}
\item a (partial) {\em order} on the tag set
\item an {\em addition operation} that adds delays to tags to yield
  larger tags
\item a {\em zero delay} that is the neutral delay with respect to
  that addition.
\end{itemize}

\index{time@\kwTime}

The actor specification, however, only contains the delays. For this
reason, the optional \kwTime-tag in the actor header is only followed
by one type,\sidenote{delay type} the type of the delay values in
action descriptions (see section \ref{sect:Delays}). This type must
have the following properties:
\begin{itemize}
\item There must be a partial order that is compatible with the
  addition operation used to add the time delay to tags. More
  precisely, for any tag $t$, and any two delays $d_1$, $d_2$, the
  following must hold:
  \[d_1 < d_2 \Longrightarrow (t + d_1) < (t + d_2)\]
\item There must be a zero delay, say $z$, which defines the set of
  valid delays of the specified type as follows. If $d$ is of the
  delay type, it is valid iff $z \leq d$.
\end{itemize}

\sidenote{time-clause: static type declaration}The time-clause in the
actor head functions as a type declaration for the delays. Its
presence does {\em not} imply that any or all actions have non-zero
delays, and neither does its absence imply that all actions have zero
delays---unless a platform requires type information to be added, in
which case an actor that contained delay-clauses in actions but no
time-clause would not typecheck and hence not be well-formed.

See section \ref{sect:Delays} on how to specify time delays in actions.
 
\index{time|)}
\index{delay|)}
\index{time system|)}


% Local Variables:
% TeX-master: "../reference"
% End:



