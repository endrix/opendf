/* 
BEGINCOPYRIGHT X
	
	Copyright (c) 2007, Xilinx Inc.
	All rights reserved.
	
	Redistribution and use in source and binary forms, 
	with or without modification, are permitted provided 
	that the following conditions are met:
	- Redistributions of source code must retain the above 
	  copyright notice, this list of conditions and the 
	  following disclaimer.
	- Redistributions in binary form must reproduce the 
	  above copyright notice, this list of conditions and 
	  the following disclaimer in the documentation and/or 
	  other materials provided with the distribution.
	- Neither the name of the copyright holder nor the names 
	  of its contributors may be used to endorse or promote 
	  products derived from this software without specific 
	  prior written permission.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND 
	CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
	CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
	NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
	OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	
ENDCOPYRIGHT
*/

/**
	Instruction decoder component for the Mini Dataflow Processor
	
	@author JWJ
*/

import all caltrop.lib.BitOps;

actor InstructionDecoder () 
  data I, void Reset ==> 
  boolean W, data Offset, 
  pcCmd PcOp, data PcVal,
  aluCmd AluOp,
  rfCmd RfOp, reg R1, reg R2, data RfVal:


  Init: action ==> RfOp: [0], PcOp: [0] end

  Reset: action Reset: [_] ==> RfOp: [0], PcOp: [0] end

  // STOP
  Stop: action I: [op] ==> 
        guard
          opcode1(op) = 0x3f
        end

  // ADD
  Op.ADD: action I: [op] ==> PcOp: [1],   // NEXT
                             AluOp: [1],  // ADD
                             RfOp: [2, 9],  // READ-AB, STORE2
                             R1: [r1(op), rd(op)],
                             R2: [r2(op)]
      guard oc1 = 0 and oc2 = 0x20   // ADD
      var 
        oc1 = opcode1(op), oc2 = opcode2(op)
      end

  // ADDI
  Op.ADDI: action I: [op] ==> PcOp: [1],   // NEXT
                              AluOp: [1],  // ADD
                              RfOp: [1, 9], // READ-A, STORE2
                              RfVal: [n],
                              R1: [r1(op), r2(op)]
      guard oc1 = 0x08   // ADDI
      var 
        oc1 = opcode1(op),
        n = extend16to32(immediate(op))
      end

  // SUB
  Op.SUB: action I: [op] ==> PcOp: [1],   // NEXT
                             AluOp: [2],  // SUB
                             RfOp: [2, 9],  // READ-AB, STORE2
                             R1: [r1(op), rd(op)],
                             R2: [r2(op)]
      guard oc1 = 0 and oc2 = 0x22   // SUB
      var 
        oc1 = opcode1(op), oc2 = opcode2(op)
      end

  // SUBI
  Op.SUBI: action I: [op] ==> PcOp: [1],   // NEXT
                              AluOp: [2],  // SUB
                              RfOp: [1, 9], // READ-A, STORE2
                              RfVal: [n],
                              R1: [r1(op), r2(op)]
      guard oc1 = 0x0A   // SUBI
      var 
        oc1 = opcode1(op),
        n = extend16to32(immediate(op))
      end

  // AND
  Op.AND: action I: [op] ==> PcOp: [1],   // NEXT
                             AluOp: [3],  // AND
                             RfOp: [2, 9],  // READ-AB, STORE2
                             R1: [r1(op), rd(op)],
                             R2: [r2(op)]
      guard oc1 = 0 and oc2 = 0x24   // ADD
      var 
        oc1 = opcode1(op), oc2 = opcode2(op)
      end

  // ANDI
  Op.ANDI: action I: [op] ==> PcOp: [1],   // NEXT
                              AluOp: [3],  // AND
                              RfOp: [1, 9], // READ-A, STORE2
                              RfVal: [n],
                              R1: [r1(op), r2(op)]
      guard oc1 = 0x0C   // ADDI
      var 
        oc1 = opcode1(op),
        n = extend16to32(immediate(op))
      end

  // SW
  Op.SW: action I: [op] ==> PcOp: [1],   // NEXT
                            RfOp: [5], // SENDMEMDATA
                            Offset: [n],
                            R1: [r1(op)],
                            R2: [r2(op)],
                            W: [true]                            
      guard oc1 = 0x2B   // SW
      var 
        oc1 = opcode1(op),
        n = extend16to32(immediate(op))
      end

  // LW
  Op.LW: action I: [op] ==> PcOp: [1],   // NEXT
                            RfOp: [4, 10], // SENDMEM, STORE3
                            Offset: [n],
                            R1: [r1(op), r2(op)],
                            W: [false]
      guard oc1 = 0x23   // SW
      var 
        oc1 = opcode1(op),
        n = extend16to32(immediate(op))
      end

  // BEQZ
  Op.BEQZ:  action I:[op] ==> PcOp: [6],  // B-TRUE
                              RfOp: [3], // TEST
                              R1: [r1(op)],
                              PcVal: [n]
      guard oc1 = 0x04   // BEQZ
      var 
        oc1 = opcode1(op),
        n = extend16to32(immediate(op))
      end

  // BNEZ
  Op.BNEZ:  action I:[op] ==> PcOp: [7],  // B-FALSE
                              RfOp: [3], // TEST
                              R1: [r1(op)],
                              PcVal: [n]
      guard oc1 = 0x05   // BNEZ
      var 
        oc1 = opcode1(op),
        n = extend16to32(immediate(op))
      end

  // J
  Op.J: action I:[op] ==> PcOp: [2],  // JUMP
                          PcVal: [n]
      guard oc1 = 0x02   // J
      var 
        oc1 = opcode1(op),
        n = extend24to32(jvalue(op))
      end



  Error: action I: [op] ==> 
         do
           println("DLX ERROR: " + op + " :: " + opcode1(op) + "-" + rshift(op, 26) + "---" + opcode2(op));
         end

  priority 
    Reset > Stop;
    Reset > Op;
    Stop > Error;
    Op > Error;
  end

  schedule fsm Initializing:
    Initializing (Init) --> Running;
    Running (Op, Reset) --> Running;
    Running (Stop) --> Stopped;
    Stopped (Reset) --> Running;
    Running (Error) --> Crashed;
  end
  

  
  function opcode1 (n) :
    bitand(rshift(n, 26), 0x3f)
  end

  function opcode2 (n) : 
    bitand(n, 0x3f)
  end

  function immediate(n) :
    bitand(n, 0xffff)
  end

  function jvalue(n) :
    bitand(n, 0xffffff)
  end

  function extend16to32(n) :
    if bitand(n, 0x8000) = 0 then bitand(n, 0x7FFF) else bitand(n, 0x7FFF) - 0x8000 end
  end

  function extend24to32(n) :
    if bitand(n, 0x800000) = 0 then bitand(n, 0x7FFFFF) else bitand(n, 0x7FFFFF) - 0x800000 end
  end

  function r1(n) :
    bitand(rshift(n, 21), 0x1f)
  end  

  function r2(n) :
    bitand(rshift(n, 16), 0x1f)
  end  

  function rd(n) :
    bitand(rshift(n, 11), 0x1f)
  end  

  function val(n) :
    bitand(n, 0x3ffffff)
  end

  function rfcmd(op, a, b)
  var 
    h1 = lshift(bitand(op, 0xf), 10), 
    h2 = lshift(bitand(a, 0x1f), 5), 
    h3 = bitand(b, 0x1f) 
    :
    bitor(bitor(h1, h2), h3)
  end

end



