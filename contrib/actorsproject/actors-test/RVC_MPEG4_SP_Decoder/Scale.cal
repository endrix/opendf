// ECARVON modified: initializer, comprehension->loop

import all caltrop.lib.BitOps;

actor Scale (int SIN_SZ, int SOUT_SZ) int (size=SIN_SZ) SIn ==> int (size=SOUT_SZ) SOut :

int A = 1024;
int B = 1138;
int C = 1730;
int D = 1609;
int E = 1264;
int F = 1922;
int G = 1788;
int H = 2923;
int I = 2718;
int J = 2528;

List(type:int(size=13), size=64) scale =
[ 
A, B, C, D, A, D, C, B,
B, E, F, G, B, G, F, E,
C, F, H, I, C, I, H, F,
D, G, I, J, D, J, I, G,
A, B, C, D, A, D, C, B,
D, G, I, J, D, J, I, G,
C, F, H, I, C, I, H, F,
B, E, F, G, B, G, F, E
];

List(type:int, size=64) dummyInit64=[0 : for i in Integers(0,63)];

  action SIn: [x] repeat 64 ==> SOut: [y] repeat 64
    var 
      List (type: int(size=32), size=64) y=dummyInit64,
      int i
    do
      // y := [x[i] * scale[i]: for int i in Integers(0, 63)];
      i:=0;
      while (i<64) do
        y[i]:=x[i]*scale[i];
        i:=i+1;
      end
       y[0] := y[0] + lshift( 1, 12 );
    end
end
