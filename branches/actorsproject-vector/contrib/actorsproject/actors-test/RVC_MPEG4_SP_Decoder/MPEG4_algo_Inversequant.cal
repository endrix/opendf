// MPEG4_algo_Inversequant.cal
//
// Author: David B. Parlour (dave.parlour@xilinx.com)
//
// Copyright (c) 2004-2005 Xilinx Inc.
// All Rights Reserved
//
// Disclaimer:  THIS PROGRAM IS PROVIDED "AS IS" WITH NO WARRANTY 
//              WHATSOEVER AND XILINX SPECIFICALLY DISCLAIMS ANY 
//              IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
//              A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.

// MPEG-4 inverse quantization function

// ECARVON: comprehension --> loop

import all caltrop.lib.BitOps;

actor MPEG4_algo_Inversequant ( int QUANT_SZ, int SAMPLE_SZ ) int(size=SAMPLE_SZ) DC, int(size=SAMPLE_SZ) AC, int(size=QUANT_SZ) QP ==> int(size=SAMPLE_SZ) OUT :

  function saturate( int x ) --> int
    var
      bool minus = x < -2048,
      bool plus  = x >  2047 :
    if minus then -2048 else if plus then 2047 else x end end
  end

  int(size=7) count;
  int(size=QUANT_SZ) quant;
  int(size=2) round;

  get_qp: action QP:[ q ], DC:[i] ==> OUT:[i]
  do
    quant := q;
    round := bitxor( bitand( q, 1 ), 1 );
    count := 0;
  end


  function abs( int x ) --> int :
    if x < 0 then - x else x end
  end

  ac: action AC:[i] repeat 63 ==> OUT:[o] repeat 63
  var
    int(size=SAMPLE_SZ) v,
    List(type:int(size=SAMPLE_SZ),size=63) o=[ 0 : for k in Integers(0,62)],
    int j
  do
    // v = [( quant * ( lshift( abs(i[j]), 1) + 1) ) - round  
    //     : for int j in Integers(0,62)],

    // o = [ if i[k] = 0 then 0 
    //       else if i[k] < 0 then saturate(-v[k]) 
    //       else saturate(v[k]) end end : for int k in Integers(0,62)]
    j:=0;
    while (j<63) do
      v := quant*(lshift( abs(i[j]), 1) + 1) - round;
      o[j] := if i[j] = 0 then 0
              else if i[j]<0 then saturate(-v)
              else saturate(v) end end;
      j := j + 1;
    end
  end

  schedule fsm start :
    start  ( get_qp  ) --> ac;
    ac     ( ac    ) --> start;
  end
end