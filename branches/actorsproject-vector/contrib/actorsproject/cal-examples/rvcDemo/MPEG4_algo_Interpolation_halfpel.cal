// MPEG4_algo_Interpolation_halfpel.cal
//
// Author: David B. Parlour (dave.parlour@xilinx.com)
//
// Modified by: Carl von Platen (carl.von.platen@ericsson.com) 
//              Ericsson AB, 2009
//              Now uses repeats and separate actions for the
//              different interpolation modes
//
// Copyright (c) 2004-2005 Xilinx Inc.
// All Rights Reserved
//
// Disclaimer:  THIS PROGRAM IS PROVIDED "AS IS" WITH NO WARRANTY 
//              WHATSOEVER AND XILINX SPECIFICALLY DISCLAIMS ANY 
//              IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
//              A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.

// Interpolation for motion compensation

import all caltrop.lib.BitOps;

actor MPEG4_algo_Interpolation_halfpel ( int PIX_SZ, int FLAG_SZ ) int(size=PIX_SZ) RD, int(size=FLAG_SZ) halfpel ==> int(size=PIX_SZ) MOT :

  bool _CAL_tokenMonitor := true;

  none: action halfpel:[ flags ], RD:[rd] repeat 81 ==> MOT:[mot] repeat 64
  guard
    rshift(flags,1) = 0
  var
    int rdRow,
    int motRow,
    int k,
    List(type:int(size=PIX_SZ), size=64) mot := [0 : for i in Integers(0,63)]
  do
    // mot := [ rd[9*j+k] : for k in Integers(0,7), for j in Integers(0,7)]
    rdRow:=0;
    motRow:=0;
    while (motRow<64) do
      k:=0;
      while (k<8) do
        mot[motRow+k] := rd[rdRow+k];
        k:=k+1;
      end
      rdRow:=rdRow + 9;
      motRow:=motRow + 8;
    end
  end

  row: action halfpel:[ flags ], RD:[rd] repeat 81 ==> MOT:[mot] repeat 64
  guard
    rshift(flags,1) = 1
  var
    int round := 1 - bitand(flags,1),
    int rdRow,
    int motRow,
    int k,
    List(type:int(size=PIX_SZ), size=64) mot := [0 : for i in Integers(0,63)]
  do
    // mot := [ rshift(rd[9*j+k] + rd[9*(j+1)+k] + round, 1) 
    //          : for k in Integers(0,7), for j in Integers(0,7)]
    rdRow:=0;
    motRow:=0;
    while (motRow<64) do
      k:=0;
      while (k<8) do
        mot[motRow+k] := rshift(rd[rdRow+k] + rd[rdRow+k+9] + round, 1);
        k:=k+1;
      end
      rdRow:=rdRow + 9;
      motRow:=motRow + 8;
    end
  end

  col: action halfpel:[ flags ], RD:[rd] repeat 81 ==> MOT:[mot] repeat 64
  guard
    rshift(flags,1) = 2
  var
    int round := 1 - bitand(flags,1),
    int rdRow,
    int motRow,
    int k,
    List(type:int(size=PIX_SZ), size=64) mot := [0 : for i in Integers(0,63)]
  do
    // mot := [ rshift(rd[9*j+k] + rd[9*j+k+1] + round, 1) 
    //          : for k in Integers(0,7), for j in Integers(0,7)]
    rdRow:=0;
    motRow:=0;
    while (motRow<64) do
      k:=0;
      while (k<8) do
        mot[motRow+k] := rshift(rd[rdRow+k] + rd[rdRow+k+1] + round, 1);
        k:=k+1;
      end
      rdRow:=rdRow + 9;
      motRow:=motRow + 8;
    end
  end

  both: action halfpel:[ flags ], RD:[rd] repeat 81 ==> MOT:[mot] repeat 64
  /*
   * otherwise: rshift(flags,1) = 3
   */
  var
    int round := 2 - bitand(flags,1),
    int rdRow,
    int motRow,
    int k,
    List(type:int(size=PIX_SZ), size=64) mot := [0 : for i in Integers(0,63)]
  do
    // mot := [ rshift(rd[9*j+k] + rd[9*(j+1)+k]
    //                 rd[9*(j+1)+k] + rd[9*(j+1)+k+1] + round, 2) 
    //          : for k in Integers(0,7), for j in Integers(0,7)]
    rdRow:=0;
    motRow:=0;
    while (motRow<64) do
      k:=0;
      while (k<8) do
        mot[motRow+k] := rshift(  rd[rdRow+k]   + rd[rdRow+k+1] 
                                + rd[rdRow+k+9] + rd[rdRow+k+10] + round, 2);
        k:=k+1;
      end
      rdRow:=rdRow + 9;
      motRow:=motRow + 8;
    end
  end

  priority
    none > col > row > both;
  end
end
