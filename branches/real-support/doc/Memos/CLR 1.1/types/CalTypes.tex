
\chapter{Types in the \Cal language}\label{chap:CalTypes}

This memo describes the use of {\em types} in our implementation of
the \Cal actor language \cite{CLR1}. The \Cal language itself is
largely type-agnostic, i.e. its specification makes minimal
assumptions about the existence and nature of data types. Any concrete
implementation must, of course, describe the nature of the data the
language manipulates, and how it allows users to describe it.

The way we use the term here, {\em data type} (or {\em type} for short) refers to a
collection of {\em (data) objects} or {\em values}.  If an object is a
member of the collection identified by a type, it is said to be an
{\em instance} of the type. Objects are the values of expressions, and
the contents of variables, and are characterized by the kinds of
operations that can be performed on them, and their behavior under
these operations.

Furthermore, in implementations, type information is also used to
determine how objects and variables are represented, including
important aspects of the representation such as the size (i.e. the
number of bits) required to store or communicate a data object of that
type.

Type information is also used to {\em statically check} the program
code in order to identify programming errors at during editing or at
compile time.



As mentioned in the introduction, the \Cal language itself does not
specify the concrete types that \Cal programs operate on. Instead, it
provides some generic syntax for describing types, so that those type
descriptions can become part of the text of a \Cal actor. This chapter
outlines the structure of a type description, amd some of the general
concepts regarding the use of types in the language.

Note that the actual {\em type definition} is distinct from what we
call {\em type description}. A description is a way of {\em
  identifying} a type which is assumed to be defined outside of the
program, the actor definition. Subsequet chapters will discuss the
definition of the built-in types in our implementation of \Cal.

% Types denote collections of {\em objects} of the language. Objects (or
% {\em values}) are the data items that can be the result of evaluating
% an expression. If a type contains a given object, the object is said
% to be an {\em instance} of that type. 

\section{Structure of a type description}

A data type description has three components:
\begin{enumerate}
\item The {\em type name}, identifying the {\em type class} of a type.
\item {\em Type parameters}, names bound to types.
\item {\em Value parameters}, names bound to values.
\end{enumerate}

Each type name has a (possibly empty) collection of type and value
parameters which need to be bound to types and values. The definition
of a type class may require that a parameter be specified in the
description. If a parameter is optional, the type class may assume a
default in case it is absent.

Examples:
\begin{itemize}
\item {\tt int(size=16)} --- The type of signed integers whose
  representation fits into 16 bits.
\item {\tt int} --- The type of integers without a size parameter. In
  this case, as specified by the {\tt int} type class (see section
  \ref{sect:LimitedIntegralTypes}), the {\tt size} parameter defaults
  to the value 32.
\item {\tt list(element: int(size=9), size=4)} --- The type of lists
  of 9-bit integers of length 4.
\item {\tt list(element: int(size=9))} --- The type of lists of 9-bit
  integers of any size. Note that in this case, the {\tt size}
  parameter does {\em not} assume a default value, but instead its
  absence denotes an {\em unspecified} list length, making this type
  more general than any list type with a specified {\tt size}
  parameter.
\end{itemize}


\section{Type inference on expressions}

Type inference is the process of computing a type for an expression,
such that any object that can be a result of that expression is an
instance of that type. Typically, the goal is to find the most
specific type for a given expression. 

\section{Assignability}

Assignability is the relation between two types, $T_1$ and $T_2$.
$T_1$ is said to be {\em assignable} to $T_2$, iff every instance of
$T_1$ can be assigned to a variable of $T_2$.

In practice, this means that every instance of $T_1$ must either be an
instance of $T_2$, or be automatically convertible to $T_2$---cf.
section \ref{sect:AutomaticConversions}.

\section{Conversions}

Conversions are really only mappings from the instances of one type to
those of another. We distinguish conversions that happen implicitly
and those that require the programmer to explicitly specify a
conversion. The latter are also called {\em (type) casts}.

\subsection{Automatic conversions}\label{sect:AutomaticConversions}

TBD

\subsection{Casting}

\Cal currently has no syntax for expressing explicit type casts. This
is going to change in future versions of the language.

\section{Type assertions}

\Cal currently has no syntax for expressing type assertions. This is
going to change in future versions of the language.

% Local Variables:
% TeX-master: "../CLR"
% End:





