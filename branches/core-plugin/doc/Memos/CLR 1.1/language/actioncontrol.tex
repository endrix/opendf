
\chapter{Action-level control structures}\label{chap:ActionControl}

\index{action!control structures|(}
\index{control structures!action-level|(}
\index{action!selection|(}


In \Cal, an action expresses a relation between the state of an actor
and input tokens, and the successor state of the actor and output
tokens. In general, \Cal actors may contain any number of actions, and
in a given situation, any subset of those may be ready to be executed.
For example, both actions of the following actor may be able to
execute, if there is a token available on either input port:

\index{example!actor!Nondeterministic Merge}
\begin{example}[Nondeterministic Merge]\ \sidenote{ambiguous action choice} 
\begin{alltt}actor NDMerge () A, B ==> C :

  action A: [x] ==> [x] end

  action B: [x] ==> [x] end
end
\end{alltt}
\end{example}

It is important to emphasize that the policy used to choose between
the two actions above is not part of the actor specification. In
practice, the context of the actor will make some choice, based on
whatever policy it implements. This flexibility may be desired, but
sometimes the \sidenote{control over action selection} actor writer
may want to have more control over the choice of the action---e.g., if
the {\tt Merge} actor is supposed to alternate between reading its
input ports, one might use actor state to realize this behavior:

\index{example!actor!Basic FairMerge}
\begin{example}[Basic FairMerge]\ \sidenote{using state to control
    action selection} 
\begin{alltt}actor FairMerge () A, B ==> C :

  s := 1;

  action A: [x] ==> [x]
  guard s = 1
  do
    s := 2; 
  end

  action B: [x] ==> [x]
  guard s = 2
  do
    s := 1;
  end
end
\end{alltt}
\end{example}

\index{action schedule}
\index{action!schedule}
This way of specifying action choice has two key drawbacks. First, it
is very cumbersome to write and maintain, and it does not scale very
well even for modest numbers of actions and
states. \sidenote{schedules easier to read and to analyze} Furthermore, this
way of specifying action choice essentially obfuscates the "real"
logic behind guards, state variables, and assignments, so that it
becomes harder to extract the intent from the actor description, both
for tools and for human readers. 

These are the key motivations for
using {\em action schedules}, i.e. structured descriptions of possible
orders in which actions may fire. Before we can discuss action
schedules in section \ref{sect:ActionSchedules}, we need to take a
closer look at how actions are referred to inside of them.


\section{Action tags}\label{sect:ActionNames}

\index{action!tag|(}
\index{tag!of action|(}

\index{identifier!qualified}
\index{qualified identifier}

Actions are optionally prefixed with {\em action tags} (see chapter
\ref{chap:Actions}), which are qualified identifiers:

\bgr
  ActionTag :  QualID .

  QualID : ID~\mul{'\charDot'~ID}.
\egr

\sidenote{multiple actions per tag}
The same tag may be used for more than one action. In the following,
we write the set of all actions tagged by a tag $t$ as $\overline t$,
and the tag of some action $a$ as $t_a$. The empty tag is written as
$\epsilon$, and the set of all untagged actions is therefore
$\overline\epsilon$.

\index{action!tag!prefix order}
\index{tag!of action!prefix order}
\sidenote{prefix order among tags}
\index{action!tag!extension}
\index{tag!of action!extension}
\index{extension!of action tag}
Action tags are ordered by a {\em prefix ordering}: We say that $t
\prefixOf t'$, i.e. $t$ is a {\em prefix} of $t'$, if $t'$ starts with
all the identifiers in $t$ in the same order, followed by any number
of additional identifiers, including none. For instance, $a.b.c
\prefixOf a.b.c.x$ and $a.b \prefixOf a.b$, but $a.b \not \prefixOf
a.c$. We call $t'$ an {\em extension} of $t$.

\index{action!tag!denoted actions}
\index{tag!of action!denoted actions}
\sidenote{tag: denoted action set}
When used inside action schedules and priority orderings, a tag denotes the
set of actions which are labeled with tags that are extensions of it.
For any tag $t$ this set is called $\hat t$ and is defined as follows:
\[ \hat t =_{def} \{a \mid t\prefixOf t_a\}  \]

\index{action!tag|)}
\index{tag!of action|)}


\section{Action schedules}\label{sect:ActionSchedules}

\index{action!schedule|(}
\index{schedule!of actions|(}


\sidenote{fsm \& regexp schedules}Action schedules are structured
descriptions of possible sequences in which the actions of an actor
may be executed. These sequences are either specified by a finite
state machine or a regular expression in the alphabet of action tags.
In general, like any regular language, the set of possible sequences
may be finite or infinite.

\index{action!tag!language}
\index{tag!of action!language}
\sidenote{schedule = regular tag language}Irrespective
of whether a finite state machine is used or a regular expression, an
action schedule effectively describes a (regular) language $\mathcal
L$ in the alphabet of action tags. This language is used to constrain
the legal sequences of action firings as follows.

\index{action!legal sequence of}
\index{definition!legal action sequence}
\begin{defn}[Legal action sequence]\label{def:LAS}
  Given a tag language $\mathcal L$, assume a finite sequence of
  actions $(a_i)_{i=1..n}$, and a sequence $(b_j)_{j=1..m}$ with
  $m\leq n$ and a strict monotonic function $f: \{1..m\}\longrightarrow\{1..n\}$
  such that the following holds for all $j\in \{1..m\}$ and $i\in
  \{1..n\}$:
  \sidenote{$(b_j)$ tagged subsequence of $(a_i)$}\begin{enumerate}
  \item $b_j = a_{f(j)}$
  \item $t_{b_j} \neq \epsilon$
  \item $t_{a_i} = \epsilon, \quad\forall i\not\in f^{-1}\left[\{1..m\}\right]$
  \end{enumerate}
  In other words, the $(b_j)$ are the subsequence in the $(a_i)$ with
  non-empty tags. If $(b_j)$ is empty, i.e. $m=0$, then $(a_i)$ is a {\em legal action
  sequence}.

  If $(b_j)$ is not empty, i.e. $m \geq 1$, then $(a_i)$ is a {\em legal action
    sequence} if and only if there exists a sequence of tags
  $(t_j)_{j=1..m}$ such that the following holds:
  \begin{enumerate}
  \item for all $j\in \{1..m\}$, $b_j \in \hat{t}_j$
  \item there exists a $w\in \mathcal L$ such that $(t_j) \prefixOf w$.
  \end{enumerate}
\end{defn}

\index{action!untagged!and schedules}
\sidenote{no constraints on untagged actions}
A consequence of this definition is that untagged actions may occur at
any point in the schedule---conversely, schedules do not constrain
untagged actions in any way.

We will now describe the two ways of defining a tag language: finite
state machines and regular expressions.


\subsection{Finite state machine schedules}\label{sect:FSMSchedules}

\index{action!schedule!finite state machine|(}
\index{schedule!of actions!finite state machine|(}

A finite state machine schedule defines a number of transitions
between states (and an initial state) that are each labeled with one
or more action tags.

\index{schedule@\kwSchedule}
\index{fsm@\kwFSM}
\index{:@{\tt :}!in action schedule}
\index{;@{\tt ;}!in action schedule}
\index{"|@{\tt "|}!in action schedule}
\index{end@\kwEnd}
\index{endschedule@\kwEndSchedule}
\index{(...)@{\tt (...)}!in action schedule}
\bgr
  ScheduleFSM : \kwSchedule ~[\kwFSM] ~ID ~'\charColon' ;
      \mul{StateTransition '\charSemi'} ;
      (\kwEnd|\kwEndSchedule).

  StateTransition : ID '(' ActionTags ')' '- -\charMore' ID ;
      \mul{'|' '(' ActionTags ')' '- -\charMore' ID}.

  ActionTags : ActionTag ;
      | ActionTag '\charComma' ActionTags.
\egr

\index{action!tag!language}
\index{tag!of action!language}
The state before the colon is the initial state, and all states are
accepting (or final states). The tag language is the set of all
sequences of tags that label transitions leading from the initial
state to any other state of the finite state machine.

Several transitions starting from the same state may be written as
separated by the '$\mid$' character.

The following illustrates the use of a finite state machine action
schedule to express the {\tt FairMerge} actor somewhat more concisely.

\index{example!FairMerge, with FSM schedule}
\begin{example}[FairMerge, with FSM schedule]\ 
\begin{alltt}
actor FairMerge1 () A, B ==> C :

  InA: action A: [x] ==> [x] end

  InB: action B: [x] ==> [x] end

  schedule fsm WaitA :
    WaitA (InA) --> WaitB;
    WaitB (InB) --> WaitA;
  end
end
\end{alltt}
\end{example}

\index{action!schedule!finite state machine|)}
\index{schedule!of actions!finite state machine|)}


\subsection{Regular expression schedules}\label{sect:RegexpSchedules}

\index{action!schedule!regular expression|(}
\index{schedule!of actions!regular expression|(}


In many cases, using an explicit finite state machine to define an
action schedule is still rather verbose, and specifying the tag
language through a regular expression is much more
straightforward. The syntax is as follows:

\index{schedule@\kwSchedule}
\index{regexp@\kwRegexp}
\index{end@\kwEnd}
\index{endschedule@\kwEndSchedule}
\index{(...)@{\tt (...)}!in action schedule}
\index{[...]@{\tt [...]}!in action schedule}
\index{*@{\tt *}!in action schedule}
\index{"|@{\tt "|}!in action schedule}

\bgr
  ScheduleRegExp : \kwSchedule ~\kwRegexp ~RegExp ~(\kwEnd|\kwEndSchedule).

  RegExp : ActionTag ;
      | '(' RegExp ')' ;
      | '[' RegExp ']' ;
      | RegExp '*' ;
      | RegExp ~RegExp ;
      | RegExp '|' RegExp .
\egr

\index{Kleene operator!in action schedule}
\index{regexp|see{regular expression}}
\index{regular expression!in action schedule}

The simplest regular expression (regexp) is simply a tag, which
denotes the language consisting of just this tag. Parentheses are used
to explicitly group regexps. The square brackets enclose an optional
regexp, describing the language that consists of all sequences
described by the regexp, as well as the empty sequence. The Kleene
operator '*' means repetition any number of times (including zero),
juxtaposition of two regexps denotes concatenation of sequences of the
two languages, and the '$\mid$' operator describes alternative choice.
\sidenote{operator precedence} The binding strength is the order given
above, i.e. the regexp \\
\exindent{\tt A B* | C* D}\\
is interpreted as\\
\exindent{\tt (A (B*)) | ((C*) D)}

The {\tt FairMerge} actor can be expressed with regexps as follows:

\index{example!actor!FairMerge with regexp schedule}
\begin{example}[FairMerge, with regular expression schedule]\ 
\begin{alltt}
actor FairMerge2 () A, B ==> C :

  InA: action A: [x] ==> [x] end

  InB: action B: [x] ==> [x] end

  schedule regexp 
    (InA InB)*
  end
end
\end{alltt}
\end{example}

\index{rationale!redundant action schedule syntax}
\begin{rationale}
  The reason for this conceptual redundancy is convenience---many
  schedules are best written as regular expressions. On the other
  hand, in many cases producing a regular expression can be
  cumbersome, and finite state machines are preferable.  This is
  especially true for generated code, which will usually use the
  finite state machine formulation.

  Of course, both syntaxes are of identical expressiveness, and can
  therefore be translated into one another.
\end{rationale}

Using regular expressions, control structures among actions become
much more concise and easier to read and to specify. For example,
assume we do not want to predetermine which port of the {\tt
  FairMerge} actor is read from first. It is very easy to augment the
{\tt FairMerge2} description to realize this:

\pagebreak[4]

\index{example!actor!Symmetric FairMerge}
\begin{example}[Symmetric FairMerge]\ 
\begin{alltt}
actor FairMergeSymmetric () A, B ==> C :

  InA: action A: [x] ==> [x] end

  InB: action B: [x] ==> [x] end

  schedule regexp 
    (InA InB)* | (InB InA)*
  end
end
\end{alltt}
\end{example}

\index{action!schedule!regular expression|)}
\index{schedule!of actions!regular expression|)}

\index{action!schedule|)}
\index{schedule!of actions|)}


\section{Priorities}\label{sect:ActionPriorities}

\index{action!priority|(}
\index{priority!of action|(}

\index{token!test for absence of}
\index{prefix-monotonicity}

\sidenote{priorities increase expressiveness}Priorities are very different
from action schedules in that they genuinely add to the expressiveness
of \Cal---it would not be possible in general to reduce them to
existing constructs, in the way schedules can in principle be reduced
to a state variable and guards/assignments. Among other things,
priorities allow actors to effectively test for the \sidenote{allow
  test for absence of tokens}{\em absence} of tokens. As a
consequence, actors can express non-prefix monotonic
processes,\footnote{See \cite{LeeEA97} for details on prefix
  monotonicity and its implications for the description of dataflow
  systems.} which is powerful, but at the same time can be dangerous,
because it means the results computed by an actor may depend on the
way it was scheduled with respect to the other actors in the system.

\index{action!priority!partial order}
\index{priority!of action!partial order}
\index{priority!order}

Priorities are defined as a partial order relation over action tags,
which \sidenote{induced partial order on actions}induces a partial
order relation over the actions. An action can only fire if there is
no other {\em enabled} action that is higher in this partial order.
The order is specified as follows:

\index{priority@\kwPriority}
\index{;@{\tt ;}!in priority clause}
\index{end@\kwEnd}
\index{endpriority@\kwEndPriority}
\index{>@{\tt >}!in priority clause}

\bgr
  PriorityOrder : \kwPriority \mul{PriorityInequality '\charSemi'} \kwEnd.

  PriorityInequality : ActionTag '\charMore' ActionTag \mul{'\charMore' ActionTag}.
\egr

\index{action!priority!order construction}
\index{priority!of action!order construction}
\index{priority!order!construction}

The priority inequalities are specified over tags, i.e. they have the
form $t_1 > t_2$. These inequalities induce a binary relation on the
actions are follows:
\begin{align*}
  a_1 > a_2 \Longleftrightarrow & \exists t_1, t_2: t_1 > t_2 \wedge
a_1\in\hat t_1 \wedge a_2 \in \hat t_2 \\
  \vee &\exists a_3: a_1 > a_3 \wedge a_3 > a_2
\end{align*}
\index{priority!order!validity} \sidenote{validity of priority
  system}The priority inequalities are {\em valid} iff the induced
relation $>$ on the actions is an irreflexive partial order, i.e. it
is antisymmetric and transitive.  Transitivity follows from the
definition, but antisymmetry and irreflexivity do not. In fact, they
do not even follow if the relation on the tags is a partial
order. Consider the following example:\\
\exindent{\tt A.B > X > A}\\
This is obviously a proper order on the {\em tags}. However, if we have two
actions labeled {\tt X} and {\tt A.B}, then the induced relation is
not antisymmetric, because according to {\tt A.B > X}, the action {\tt
  A.B} has higher priority than {\tt X}, while the inequality {\tt X >
  A} implies that any action whose label starts with {\tt X} has a
higher priority than any action whose label starts with {\tt A},
including, of course, {\tt A.B}. Therefore, this system of priority
inequalities is inconsistent and thus invalid.

With priorities, we can express a {\em Merge} actor that prefers one input
over the other like this:

\index{example!actor!BiasedMerge}
\begin{example}[BiasedMerge]\ 
\begin{alltt}
actor BiasedMerge () A, B ==> C :

  InA: action A: [x] ==> [x] end
  InB: action B: [x] ==> [x] end

  priority
    InA > InB;
  end
end
\end{alltt}
\end{example}

Perhaps more interestingly, we can express a merge actor that is fair,
in the sense that it will consume equal amounts of tokens from both
inputs as long as they are available, but will not halt due to lack of
tokens on only one of its input ports. It is also nondeterministic,
i.e. it does not specify the order in which it outputs the tokens.

\index{example!actor!FairMerge with priorities}
\begin{example}[FairMerge, with priorities]\ 
\begin{alltt}
actor FairMerge3 () A, B ==> C :

  Both: action [x], [y] ==> [x, y] end
  Both: action [x], [y] ==> [y, x] end
  One:  action A: [x] ==> [x] end
  One:  action B: [x] ==> [x] end

  priority
    Both > One;
  end
end
\end{alltt}
\end{example}


\index{action!priority|)}
\index{priority!of action|)}


\index{action!control structures|)}
\index{control structures!action-level|)}
\index{action!selection|)}



% Local Variables:
% TeX-master: "../reference"
% End:

















