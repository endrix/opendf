

\chapter{Statements}\label{sect:Statements}

\index{statement|(}

The execution of an action (as well as actor initialization) happens
as the execution of a (possibly empty) sequence of {\em statements}.
\sidenote{statements have``side-effects''}The only observable effect
of a statement is a change of the variable assignments in its
environment.\footnote{Other effects of statements, and indeed
  expressions, may include input/output operations, but we will
  disregard them in this context as they are not directly observable
  from within the language.} Consequently, the meaning of a statement is defined by
how the variables in its scope change due to its execution. \Cal
provides the following kinds of statements:

\index{statement!assignment}
\index{statement!block}
\index{statement!procedure call}
\index{statement!if@\kwIf}
\index{if@\kwIf!statement}
\index{statement!while@\kwWhile}
\index{while@\kwWhile!statement}
\index{statement!foreach@\kwForeach}
\index{foreach@\kwForeach!statement}
\index{statement!choice}

\bgr

Statement : AssignmentStmt ;
    | CallStmt ;
    | BlockStmt ;
    | IfStmt ;
    | WhileStmt ;
    | ForeachStmt ;
    | ChooseStmt .

\egr


\section{Assignment}\label{sect:Assignment}

\index{variable|see{assignment}}
\index{assignment|see{variable}}

\index{statement!assignment|(}
\index{assignment|(}

Assigning a new value to a variable is the
fundamental form of changing the state of an actor. The syntax is as
follows:

\index{:=@{\tt :=}!in assignments}
\index{.@{\tt .}!in assignments}
\index{[...]@{\tt [...]}!in assignments}
\index{;@{\tt ;}!in assignments}
\index{index!in assignments}
\index{field reference!in assignments}
\index{assignment!indexed}
\index{assignment!field}
\index{statement!assignment!indexed}
\index{statement!assignment!field}

\bgr
AssignmentStmt :
   ID~[Index | FieldRef]~'\charColon='~Expression~'\charSemi'.

Index : '['~[Expressions]~']'.

FieldRef : '\charDot' ID.
\egr

\index{assignment!simple}
\index{assignment!field}
\index{assignment!indexed}

\index{statement!assignment!simple}
\index{statement!assignment!field}
\index{statement!assignment!indexed}

\index{types!structured}
\index{types!mutable}

\index{mutation}

An assignment without an index or a field reference is a {\em simple
  assignment}, while one with a field reference is a {\em field
  assignment}, and one with an index is called an {\em indexed
  assignment}. Field assignments and indexed assignments are also
collectively referred to as {\em mutations} (cf. sections
\ref{sect:StructuredTypes} and \ref{sect:MutableTypes} for more
information on structured objects and mutability).

\subsection{Simple assignment}\label{sect:SimpleAssignment}

\index{assignment!simple|(}
\index{statement!assignment!simple|(}

\index{variable!assignable}

In a simple assignment, the left-hand side is a variable name. A
variable by that name must be visible in this scope, and it must be
assignable.

The expression on the right-hand side must evaluate to an object of a
value compatible with the variable \sidenote{assignability $\To$
  \ref{sect:ObjectsVariablesTypes}} (i.e. its type must be assignable
to the declared type of the variable, if any---see section
\ref{sect:ObjectsVariablesTypes}). The effect of the assignment is of
course that the variable value is changed to the value of the
expression. The original value is thereby overwritten.

\index{assignment!simple|)}
\index{statement!assignment!simple|)}



\subsection{Field assignment}\label{sect:FieldAssignment}

\index{assignment!field|(}
\index{statement!assignment!field|(}

\sidenote{assigning to field locations}If a variable is of a type that
has fields (see section \ref{sect:StructuredTypes})), and if it is
mutable (see section \ref{sect:MutableTypes}), assignments may also
selectively assign to one of the fields rather than only to the
variable itself. The syntax is as follows:

\bgr 
   FieldAssignmentStmt : ID~'\charDot'~ID~'\charColon='~Expression~'\charSemi'.  
\egr

Here, the first identifier is the variable name, while the second is
the {\em field name}, which must be valid for the variable and the
object that the variable refers to.

\index{assignment!field|)}
\index{statement!assignment!field|)}


\subsection{Assignment with indices}\label{sect:IndexedAssignment}

\index{assignment!indexed|(}
\index{statement!assignment!indexed|(}

\sidenote{assigning to indexed locations}If a variable is of a type
that is indexed, and if it is mutable, assignments may also
selectively assign to one of its indexed locations, rather than only
to the variable itself. The syntax is as follows:

\bgr 
   IndexedAssignmentStmt : ID~'['~Expressions~']'~'\charColon='~Expression~'\charSemi'.  
\egr

\sidenote{indices}In \Cal, an indexed location inside an object is specified by
a sequence of objects called {\em indices}, which are written after
the identifier representing the variable, and which enclosed in square
brackets.

\index{assignment!indexed|)}
\index{statement!assignment!indexed|)}

\subsection{Assigning to and from mutable variables}\label{sect:MutableVarAssignments}

\index{aliasing}In order to be able to reason about the actor state,
and to facilitate program transformations,\sidenote{no aliasing} \Cal
is designed to avoid {\em aliasing} of stateful structures.  In other
words, if a structure can be mutated, no two variables may point to it
at the same time.

\index{cloning}
\index{cloning!lazy}
Therefore, \sidenote{cloning}when assigning a data structure to a
mutable variable, that data structure must be cloned.\footnote{In
  fact, it must be deeply cloned, up to the point where mutations can
  occur.} Of course, this cloning operation can occur on demand, or
lazy, whenever the data structure, or a part of it, is mutated.
\sidenote{lazy cloning}Whichever implementation is chosen, mutations
via a mutable variable must never have an effect on the value of other
variables.

Similarly, when assigning {\em from} a mutable variable, the structure
assigned is conceptually copied, so that subsequent mutations of it
are not visible via the new variable. 

\index{implementation note!cloning}
\begin{implementation}
  This may pose difficult implementation issues. Consider the
  following example:

\begin{alltt}mutable List[Integer] a = ...;
List[Integer] b := f(a[7, 1111]);
\end{alltt}

Let us assume that the indexer with two arguments on {\tt List}s
computes the sublist from the first index to the second,
inclusive, i.e. {\tt a[7, 1111]} computes a list of length 1105
elements. A naive implementation would do just that, i.e. actually
create the sublist. However, if the sublist is only an intermediate
value in the computation of {\tt f}, this would be very wasteful,
e.g. in this case:
\begin{alltt}function f(List[Integer] v)-->List[Integer] :
    [#v]
end
\end{alltt}
Here, {\tt f} returns a list of length 1 whose only element is the
length of its parameter list.

Alternatively, a sublist could be represented by a special sublist-object that
is backed by the original list, thus avoiding the explicit
construction of the new structure. However, consider an {\tt f} defined like
this:
\begin{alltt}function f(List[Integer] v)-->List[Integer] :
    v
end
\end{alltt}
Now, {\tt f} returns its parameter directly, with the consequence that
whenever the original list, the one that is the value of the mutable
variable {\tt a}, is changed, so will the value of {\tt b}, because
its implementation is backed by the original list.

Obviously, an implementation that tries to achieve good performance
therefore needs to do some bookkeeping of which parts of a data
structure could be mutated, and when these get assigned to some
variable, either clone them immediately, or mark them for cloning in
case they should ever be mutated. In either case, the behavior must be
as if the mutable data structure was cloned right away.
\end{implementation}


\index{statement!assignment|)}
\index{assignment|)}


\section{Procedure call}\label{sect:Call}

\index{statement!call|(}
\index{statement!procedure call|(}
\index{procedure!call|(}

The only predefined operation on procedures (cf. section
\ref{sect:ProcClosures}) is {\em calling} them, i.e. invoking them
with a number of arguments. Calling a procedure is written as
follows:

\index{;@{\tt ;}!in procedure call}

\bgr
CallStmt : Expression~'('~Expressions~')'\charSemi'.
\egr

The first expression must evaluate to a procedure, the other
expressions must be of the appropriate argument types. The result of
this statement is the {\em execution} of the procedure, with its
formal parameters bound positionwise to the corresponding arguments.

\index{statement!call|)}
\index{statement!procedure call|)}
\index{procedure!call|)}


\section{Statement blocks (begin ... end)}\label{sect:Blocks}

\index{statement!block|(}
\index{statement!begin-end|(}

\sidenote{local scope}
Statement blocks are essentially syntactic sugar for a special case of
the call statement, used to introduce a local scope and local
variables. Their syntax looks like
this:\index{end@\kwEnd!alternatives!exception}\footnote{Note that this is
  the one exception from the general rule that each keyword construct
  can end with an end marker that consists of the string {\tt end}
  and the opening keyword. The keyword {\tt endbegin} would have
  looked too awful.}

\bgr
BlockStmt : \kwBegin~[\kwVar~VarDecls~\kwDo]~\mul{Statement}~\kwEnd .
\egr

\sidenote{special case of procedure call}
The form\\
\exindent{\tt begin var {\em decls} do {\em stmts} end}\\
is equivalent to the following procedure call:\\
\exindent{\tt proc () var {\em decls} do {\em stmts} end () ;}

\index{statement!block|)}
\index{statement!begin-end|)}

\section{If-Statement}\label{sect:IfStmt}

\index{statement!if@\kwIf|(}
\index{if-statement|(}

\index{control flow}

The if-statement is the most simple control-flow construct:

\index{if@\kwIf}
\index{then@\kwThen}
\index{else@\kwElse}
\index{end@\kwEnd}
\index{endif@\kwEndIf}

\bgr
IfStmt : \kwIf~Expression~\kwThen~\mul{Statement}~[\kwElse~\mul{Statement}]~\kwEnd
\egr


\index{Boolean@{\tt Boolean} (type)}
\index{true@\kwTrue}

As is to be expected, the statements following the \kwThen ~are
executed only if the expression evaluates to \kwTrue, otherwise the
statements following the \kwElse~ are executed, if present. The
expression must be of type {\tt Boolean}.

\index{statement!if@\kwIf|)}
\index{if-statement|)}


\section{While-Statement}\label{sect:WhileStmt}

\index{statement!while@\kwWhile|(}
\index{while-statement|(}

\index{control flow}
\index{Boolean@{\tt Boolean} (type)}

Iteration constructs are used to repeatedly execute a sequence of
statements. A \kwWhile-construct repeats execution of the statements
as long as a condition specified by a {\tt Boolean} expression is true.

\index{while@\kwWhile}
\index{do@\kwDo}
\index{end@\kwEnd}
\index{endwhile@\kwEndWhile}
\index{var@\kwVar}

\bgr
WhileStmt : \kwWhile~Expression~[\kwVar~VarDecls]~\kwDo~[Statements]~(\kwEnd|\kwEndWhile).
\egr

It is an error for the while-statement to not terminate.

\index{statement!while@\kwWhile|)}
\index{while-statement|)}



\section{Foreach-Statement}\label{sect:ForeachStmt}

\index{statement!foreach@\kwForeach|(}
\index{foreach-statement|(}

\index{control flow}


\sidenote{iteration over collections}The \kwForeach-construct allows
to iterate over collections, successively binding variables to the
elements of the collections and executing a sequence of statements for
each such binding.

\index{foreach@\kwForeach}
\index{in@\kwIn}
\index{var@\kwVar}
\index{do@\kwDo}
\index{end@\kwEnd}
\index{endforeach@\kwEndForeach}

\bgr
ForeachStmt : ForeachGenerator~\mul{'\charComma'~ForeachGenerator};
 [\kwVar~VarDecls]~\kwDo~[Statements]~(\kwEnd|\kwEndForeach).

ForeachGenerator : \kwForeach~[Type]~ID \mul{'\charComma'~ID}~\kwIn~Expression~ ;
  ['\charComma'~Expressions].
\egr

\index{generator!in foreach-statement}
\index{statement!foreach@\kwForeach!generator}

The\sidenote{relation to comprehensions $\To$
  \ref{sect:ComprehensionsWithGenerators}} basic structure and
execution mechanics of the foreach-statement is not unlike that of the
comprehensions with generators discussed in section
\ref{sect:ComprehensionsWithGenerators}. However, where in the case of
comprehensions a collection was constructed piecewise through a number
of steps specified by the generators, a foreach-statement executes a
sequence of statements for each complete binding of its generator
variables.

\index{example!foreach-statement}
\begin{example}
  The following code fragment
\begin{alltt}   s := 0;
   foreach a in \{1, 2\}, b in \{1, 2\}:
     s := s + a*b;
   end
\end{alltt}
results in {\tt s} containing the number 9.
\end{example}

\index{foreach-statement!semantics}
\index{statement!foreach@\kwForeach!semantics}
\paragraph{Foreach-statement semantics.}
\sidenote{foreach $v_{1, 1},...,v_{1, M_1}$ in $C_1$, $F_{1, 1}, ...,
  F_{1, K_1}$, ..., \\ foreach $v_{n, 1},...,v_{n, M_n}$ in $C_n$,
  $F_{n, 1}, ..., F_{n, K_n}$ \\ var $D$ do $B$ end}In order to
precisely describe the execution of a foreach-statement, we need to introduce a few symbols first. We
call the original foreach-statement $S$. The (optional) declarations
we write as $D$, and the body of the foreach-statement as $B$. Now $S$ has $N \geq
1$ generators. The $i$-th generator has $M_i \geq 1$ variables, with
names $v_{i,1}, ..., v_{i, {M_i}}$. The collection expression of the
$i$-th generator will be called $C_i$.  Following the $i$-th generator
are $K_i \geq 0$ filter expressions, which we call $F_{i, 1}, ...,
F_{i, {K_i}}$. 

We can now define the meaning of the foreach-statement by replacing it
\sidenote{syntactical transformation of foreach-statement}with a
number of previously described constructs, such as procedure closures,
procedure call, and if-statement. The key to this replacement is a
function {\tt \$iterate}, which we will describe below.

\begin{align*}
  S & \equiv G(1) \\
  G(i) & \equiv 
  \begin{cases}
    \lit{begin var}~D~\lit{do}~B~\lit{end} &\quad i > N\\
    \lit{begin var}~a_i ~\lit{=} ~C_i ~\lit{do}~
    G_V(i, 1) ~\lit{end} &\quad \text{otherwise} 
  \end{cases}\\
  G_V(i, j) &\equiv
  \begin{cases}
    G_F(i, 1) &\quad j > M_i \\
    \lit{\$iterate(}a_i\lit{, proc (}v_{i, j}\lit{) do}~G_V(i, j +
    1)~\lit{end)} &\quad \text{otherwise}
  \end{cases}\\
  G_F(i, k) &\equiv
  \begin{cases}
    G(i+1) &\quad k > K_i\\
    \lit{if}~F_{i, k}~\lit{then}~G_F(i, k+1)~\lit{end} &\quad\text{otherwise}
  \end{cases}
\end{align*}

The $a_i$ are distinct and fresh variable symbols, i.e. they are
mutually different, and they also differ from any variable symbol
occurring inside the foreach-statement.

\index{\$iterate@{\tt \$iterate}!use in foreach-statement}
\sidenote{{\tt \$iterate}:\\\hspace*{5mm}{\tt
    Collection[T]}\\\hspace*{5mm}{\tt [T-->]}\\Def. $\To$ \ref{sect:Collections}} The {\tt \$iterate}
procedure takes two arguments, a collection and a unary procedure. It
iterates over the elements of its first argument, and calls the
procedure on each element. {\tt \$iterate} is defined in appendix
\ref{sect:Collections}.

See also page \pageref{lbl:RationaleIteratorName} for an explanation
of the iterator name choice, and page
\pageref{lbl:GeneratorEfficiency} for a note concerning the efficiency
of generator implementations via syntactic substitution.

\index{statement!foreach@\kwForeach|)}
\index{foreach-statement|)}


\section{Choose-Statement}\label{sect:NDChoice}

\index{statement!choose@\kwChoose|(}
\index{choose-statement|(}
\index{nondeterminism!choose-statement|(}

The choose-statement permits the explicit specification of
(potentially nondeterministic) choice among a set of alternatives.

\index{choose@\kwChoose}
\index{in@\kwIn}
\index{var@\kwVar}
\index{do@\kwDo}
\index{else@\kwElse}
\index{end@\kwEnd}
\index{endchoose@\kwEndChoose}

\bgr
ChooseStmt : ChooseGenerator~\mul{'\charComma'~ChooseGenerator};
     [\kwVar~VarDecls]~\kwDo~[Statements]~ ;
     [\kwElse
     [[\kwVar~LocalVarDecls]~\kwDo]~[Statements]~]~(\kwEnd|\kwEndChoose).

ChooseGenerator : \kwChoose~[Type]~ID~['\charComma'~IDs]~\kwIn~Expression~['\charComma'~Expressions].
\egr

\index{foreach-statement}
\index{statement!foreach@\kwForeach}

The binding of values to variables happens very much like in the case
of comprehension generators or the foreach-statement---see below for a
precise definition of the semantics.

\index{else@\kwElse!in foreach-statement}
\index{choose-statement!filter}

In contrast to the foreach-statement, the choose-statement executes
its body at most once, viz. for the first combination of values that
satisfy all the filters (which are part of the generators just as in
the case of the foreach-statement or collection comprehensions). If no
such combination can be found, and if an else-branch is present, the
statements following the \kwElse-keyword are executed instead.

\index{choose-statement!semantics}
\index{statement!choose@\kwChoose!semantics}
\paragraph{Choose-statement semantics.}
In order
to precisely describe the execution of a choose-statement, we need to
introduce a few symbols first. We call the original choose-statement
$S$. The (optional) declarations we write as $D$, and the body of the
foreach-statement as $B$, the else branch is $E$. Now $S$ has $N \geq
1$ generators. \sidenote{choose $v_{1, 1},...,v_{1, M_1}$ in $C_1$, $F_{1, 1}, ...,
  F_{1, K_1}$, ..., \\ choose $v_{n, 1},...,v_{n, M_n}$ in $C_n$,
  $F_{n, 1}, ..., F_{n, K_n}$ \\ var $D$ do $B$ else $E$ end}The $i$-th generator has $M_i \geq 1$ variables, with
names $v_{i,1}, ..., v_{i, {M_i}}$. The collection expression of the
$i$-th generator will be called $C_i$.  Following the $i$-th generator
are $K_i \geq 0$ filter expressions, which we call $F_{i, 1}, ...,
F_{i, {K_i}}$.

We can now define the meaning of the choose-statement by replacing it
with a number of previously described constructs, such as procedure
closures, procedure call, and if-statement. The key to this
replacement is a function {\tt \$try}, which we will describe
below.

\sidenote{syntactical transformation of choose-statement}
\begin{align*}
  S & \equiv \lit{begin var}~a_*~\lit{:= false do}~G(1)~\lit{if
    not}~a_*~\lit{then}~E~\lit{end end} \\
  G(i) & \equiv 
  \begin{cases}
    \lit{begin var}~D~\lit{do}~a_*~\lit{:= true;}~B~\lit{end} &\quad i > N\\
    \lit{begin var}~a_i ~\lit{=} ~C_i ~\lit{do}~
    G_V(i, 1) ~\lit{end} &\quad \text{otherwise} 
  \end{cases}\\
  G_V(i, j) &\equiv
  \begin{cases}
    G_F(i, 1) &\quad j > M_i \\
    \lit{\$try(}a_i\lit{, proc (}v_{i, j}\lit{) do}~G_V(i, j +
    1)~\lit{end, lambda() :}~a_*~\lit{end)} &\quad \text{otherwise}
  \end{cases}\\
  G_F(i, k) &\equiv
  \begin{cases}
    G(i+1) &\quad k > K_i\\
    \lit{if}~F_{i, k}~\lit{then}~G_F(i, k+1)~\lit{end} &\quad\text{otherwise}
  \end{cases}
\end{align*}

The $a_i$ and $a_*$ are distinct and fresh variable symbols, i.e. they
are mutually different, and they also differ from any variable symbol
occurring inside the choose-statement.

\index{\$try@{\tt \$try}!use in choose-statement} 
\index{Boolean@{\tt Boolean} (type)}
\index{false@\kwFalse}


\sidenote{{\tt \$try}:\\
  \hspace*{5mm}{\tt Collection[T]}\\
  \hspace*{5mm}{\tt [T-->]}\\
  \hspace*{5mm}{\tt [-->Boolean]}\\ Def. $\To$
  \ref{sect:Collections}}The {\tt \$try} procedure takes three
arguments, a collection, a unary procedure, and a nullary function. It
iterates over the elements of its first argument, and for each element
it does the following: It applies the function (to no arguments, as it
is nullary). If the value of that application is \kwFalse, it proceeds
to call the procedure (its second argument) on the element, otherwise
it simply returns (disregarding any subsequent elements of the
collection).

See also page \pageref{lbl:RationaleIteratorName} for an explanation
of the iterator name choice, and page
\pageref{lbl:GeneratorEfficiency} for a note concerning the efficiency
of generator implementations via syntactic substitution. {\tt \$try}
is defined in appendix \ref{sect:Collections}.

\index{rationale!choose-statement}
\begin{rationale}
  Having a construct that explicitly allows the use of non-determinism
  (as opposed to expressions, such as map comprehensions, that may
  evaluate nondeterministically, but where this behavior is most
  likely unwanted and potentially erroneous) allows actor authors to
  express internal choice points which are explicitly not under the
  control of the actor context (i.e. the model of computation).
  
  The responsibility for many other choices, such as which action to
  fire, can be assumed by the model of computation. Using a
  choose-statement inside an action provides an explicit signal that
  this action may be nondeterministic, and allows the model of
  computation to either reject it, or deal with it accordingly.
\end{rationale}

\index{backtracking!and choose-statement}
\index{choose-statement!backtracking}
\index{statement!choose@\kwChoose!backtracking}
\index{example!backtracking using choose-statement}

\sidenote{backtracking}
\begin{example}
  The choose-statement can be used to implement simple backtracking
  algorithms, as in the following example:
\begin{alltt}  s := null;
  choose 
    a in [1, 2],
  choose 
    b in if a = 1 then \{\} else \{3, 4\} end
  do
    s := [a, b];
  else
    s := [];
  end
\end{alltt}
Since for {\tt a = 1} the collection for {\tt b} is the empty set, the
body will never be executed for this value of {\tt a}, because no
choice could be made for {\tt b}. However, if {\tt a = 2}, two choices
can be made for {\tt b}, and it is unspecified which one is
made. After executing this statement, {\tt s} will be either {\tt [2,
  3]} or {\tt [2, 4]}.

It will never be {\tt []}, because the else branch is only executed if
no choice can be made.
\end{example}


\index{statement!choose@\kwChoose|)}
\index{choose-statement|)}
\index{nondeterminism!choose-statement|)}



\index{statement|)}






% Local Variables:
% TeX-master: "../reference"
% End:
