
\chapter{Actions}\label{chap:Actions}

\index{action|(}

\index{action!and transition}
\index{transition!and action}
\index{actor!transition!relation to action}

\index{token!input} \index{input token}
\index{token!output} \index{output token}
\index{actor!state!change}
\index{state!of actor!change}
\index{firing condition}
\index{condition!for firing}
\index{delay}
\index{action!delay}

\sidenote{action $\equiv$ family of transitions}An {\em action} in
\Cal represents a (often large or even infinite) number of {\em
  transitions}. A \Cal actor description can contain any number of
actions, including none. The definition of an action includes the
following information:
\begin{itemize}
\item its {\em input tokens},
\item its {\em output tokens},
\item the {\em state change} of the actor,
\item additional {\em firing conditions},
\item the {\em time delay}.
\end{itemize}

\index{action!choice}
In any given state, an actor may take any number of transitions
\sidenote{choice between actions}(including zero), and these
transitions may be represented by any number of actions in the actor
description. The choice between them is ultimately made by the context
of an actor (though the actor can constrain the possible choices, see
chapter \ref{chap:ActionControl})---see section
\ref{sect:ActionSelection} for details.

The syntax of an action definition is as follows:

\index{:@{\tt :}!after action tag}
\index{action!tag}
\index{action@\kwAction}
\index{do@\kwDo}
\index{end@\kwEnd}
\index{endaction@\kwEndAction}
\index{.@{\tt .}!in action tag}
\index{==>@{\tt ==>}!in action head}
\index{guard@\kwGuard}
\index{var@\kwVar}
\index{delay@\kwDelay}


\bgr
Action : [ActionTag '\charColon']~\kwAction~ ActionHead ~[\kwDo ~Statements]~ (\kwEnd|\kwEndAction).

ActionTag : ID ~\mul{'\charDot'~ID}.

ActionHead : InputPatterns~'==\charMore'~OutputExpressions;
             [\kwGuard~Expressions ] ~[\kwVar~VarDecls ] ~[\kwDelay ~Expression].
\egr

\index{action!tag}

\sidenote{action tags}Actions are optionally preceded by {\em action
  tags} which come in the form of qualified identifiers (i.e.
sequences of identifiers separated by dots), see also section
\ref{sect:ActionNames}. These tags need not be unique, i.e. the same
tag may be used for more than one action.  Action tags are used to
refer to actions, or sets of actions, in action schedules and action
priority orders---see chapter \ref{chap:ActionControl} for details.

\index{action!head} \index{action!body}

The head of an action contains a description of the kind of inputs
this action applies to, as well as the output it produces. The body of
the action is a sequence of statements that can change the state, or
compute values for local variables that can be used inside the output
expressions.

\index{input pattern!association with port}
\index{output expression!association with port}
\index{port!and input patterns}
\index{port!and output expression}

Input patterns and output expressions are associated with ports either
by position or by name. These two kinds of association cannot be
mixed. So if the
actor's port signature is\\
\exindent{\tt Input1, Input2 ==> ...}\\
an input pattern may look like this:\\
\exindent{\tt [a], [b, c]}\\
(binding {\tt a} to the first token coming in on {\tt Input1}, and
binding {\tt b} and {\tt c}
to the first two tokens from {\tt Input2}). It may also look like this:\\
\exindent{\tt Input2: [c]}\\
but never like this:\\
\exindent{\tt [d] Input2:[e]}\\
This mechanism is the same for input patterns and output expressions.

The following sections elaborate on the structure of the input
patterns and output expressions describing the input and output
behavior of an action, as well as the way the action is selected from
the set of all actions of an actor.

In discussing the meaning of actions and their parts it is important
\sidenote{actions declarative}to keep in mind that the interpretation
of actions is left to the model of computation, and is not a property
of the actor itself. It is therefore best to think of an action as a
declarative description of how input tokens, output tokens, and state
transitions are related to each other. See also section
\ref{sect:ActionSelection}.


\section{Input patterns, and variable
  declarations}\label{sect:InputPatterns}

\index{input pattern|(}

\index{action!firability}
\index{input pattern!implicit variable declaration}

Input patterns, together with variable declarations and guards,
\sidenote{input pattern:\\activation condition \& variable declaration}perform two main functions: (1) They define the input tokens required
by an action to fire, i.e. they give the basic conditions for the
action to be {\em firable} which may depend on the value and number of
input tokens and on the actor state, and (2) they declare a number of
variables which can be used in the remainder of the action to refer to
the input tokens themselves. This is their syntax:

\index{repeat@\kwRepeat}
\index{at@\kwAt}
\index{at*@\kwAtN}
\index{any@\kwAny}
\index{all@\kwAll}
\index{[...]@{\tt [...]}!in input pattern}
\index{:@{\tt :}!in input pattern}

\bgr
InputPattern : [ID~'\charColon']~'['~IDs~']'~[RepeatClause]~[ChannelSelector].

ChannelSelector : \kwAt~Expression ;
     | \kwAtN~Expression ; 
     | [\kwAtN]~\kwAny~;
     | [\kwAtN]~\kwAll.

RepeatClause : \kwRepeat~Expression.
\egr

\index{port!single port!and input pattern}
\index{multiport!and input pattern}
\index{port!multiport!and input pattern}
\index{single port!and input pattern}
\index{channel selector}
\index{input pattern!channel selector}

Input patterns differ depending on whether they are written for a
\sidenote{multiport pattern\\---channel selector}
single port or a multiport---the former represents one {\em channel}
of incoming tokens, while the latter represents an arbitrary number
(including zero) of channels. A multiport input pattern has to have a
{\em channel selector} associated with it, which is a construction
that serves to specify the channels that a pattern is applied to
(i.e. that the tokens bound by the pattern are read from).

\begin{table}[t]
\center{
\begin{tabular}{|r|c|c|}\hline
     & no repeat-clause & with repeat-clause \\ \hline\hline
single channel & {\tt T} & {\tt List[T]} \\ \hline
multichannel & {\tt Map[CID, T]} & {\tt Map[CID, List[T]]} \\ \hline
\end{tabular}
}
\caption{Token variable types depending on input pattern kind and
  presence of repeat-clause. ({\tt T} is the token type of the
  corresponding input port.)}\label{fig:TokenVarTypes}

\index{input pattern!variable!type, table@type, table, Fig. \ref{fig:TokenVarTypes}}
\index{pattern variable!type!table@table, Fig. \ref{fig:TokenVarTypes}}
\end{table}

\index{types!of token}
\index{repeat-clause!in input pattern}
\index{input pattern!single-channel}
\index{single-channel input pattern}
\index{input pattern!multichannel}
\index{multichannel input pattern}
\index{channel identifier}
\index{port!single port} \index{single port}
\index{port!multiport} \index{multiport}

The static type of the variables declared in an input pattern depends
on the token type declared on the input port, but also on the kind of
pattern. Fig. \ref{fig:TokenVarTypes} shows this dependency. It
distinguishes between patterns according to whether they contain a
repeat-clause, and whether they take tokens from one channel ({\em
  single-channel patterns}), or any number of channels ({\em
  multichannel patterns}). Channels are specified using {\em channel
  identifiers}, which are objects identifying a specific channel
inside a multiport. Usually, channel identifiers are represented by
some other type in some platform-dependent manner. For instance,
non-negative integer numbers can be used to identify channels. Fig.
\ref{fig:TokenVarTypes} refers to the type of channel identifiers as
{\em CID}.

\subsection{Single-port input patterns}

\index{input pattern!single-port|(}
\index{single-port input pattern|(}

\sidenote{single-port $\Longrightarrow$ single-channel}A single-port
input pattern binds a number of tokens from the input channel
associated with the specified port to variables specified as part of
the pattern. Because there is exactly one input channel associated
with a single port, these patterns are always single-channel patterns.

\bgr
SinglePortInputPattern : [ID~'\charColon']~'['~IDs~']'~[RepeatExpression].
\egr

A pattern without a repeat-expression is just a number of variable
names inside square brackets. The pattern binds each of the variable
names to one token, reading as many tokens as there are variable
names. The number of variable names is also referred to as the {\em
  pattern length}. The static type of the variables is the same as the
token type of the corresponding port (Fig. \ref{fig:TokenVarTypes}).

\index{example!single-port input pattern}
\begin{example}[Single-port input pattern]
  Assume the sequence of tokens on the input channel is the natural
  numbers starting at 1, i.e.\\
  \exindent{\tt 1, 2, 3, 4, 5, ...}

  The input pattern {\tt [a, b, c]} results in the following
  bindings:\\
  \exindent{\tt a = 1, b = 2, c = 3}
\end{example}

\index{repeat-clause!in input pattern}

If the pattern contains a repeat-clause, that expression must
evaluate to a non-negative integer, say $N$. If the pattern length is
$L$, the number of tokens read by this input pattern and bound to the $L$
pattern variables is $N L$. Since in general there may be more
tokens than variables ($N$ times more, exactly), variables are bound
to {\em lists} of tokens, each list being of length $N$. In the
pattern, the list bound to the $k$-th variable contains the tokens
numbered $k$, $L+k$, $2L+k$, ..., $(N-1)L+k$. The static type of these
variables is {\tt List[T]}, where {\tt T} is the token type of the
port (Fig. \ref{fig:TokenVarTypes}).

\index{example!single-port input pattern with repeat-clause}
\begin{example}[Single-port input pattern with repeat-clause]
  Assume again the natural numbers as input sequence. If the input pattern
  is\\
  \exindent{\tt [a, b, c] repeat 2}\\
  it will produce the following bindings:\\
  \exindent{\tt a = [1, 4], b = [2, 5], c = [3, 6]}
\end{example}

\index{input pattern!single-port|)}
\index{single-port input pattern|)}



\subsection{Multiport input patterns}

\index{input pattern!multiport|(}
\index{multiport input pattern|(}

\index{channel selector}
\index{channel selector!single-channel}
\index{channel selector!multichannel}

\sidenote{channel selector: one or many}Multiport input patterns
contain an expression that functions as a {\em channel selector}, i.e.
it specifies which channels to read tokens from. There are two kinds of
channel selectors---those that identify precisely one channel, and
those that identify any number of channels.

\index{at@\kwAt}
\index{channel selector!single-channel}
\index{single-channel channel selector}

\paragraph{Single-channel channel selectors.} The \kwAt-construct is used to select one
channel from a multiport. The expression following the \kwAt-keyword
must evaluate to a valid channel identifier for the given port. The
reading of tokens and binding to the pattern variables happens in the
same way as described for single-port input patterns above.

\begin{example}[\kwAt~channel selector]
  Assume four input channels {\tt 'a'}, {\tt 'b'}, {\tt 'c'}, {\tt 'd'} with the following input tokens:\\
  \exindent{\tt 'a': 11, 12, 13, 14, 15, 16, 17, 18, 19}\\
  \exindent{\tt 'b': 21, 22, 23, 24, 25, 26, 27, 28, 29}\\
  \exindent{\tt 'c': 31, 32, 33, 34, 35, 36, 37, 38, 39}\\
  \exindent{\tt 'd': 41, 42, 43, 44, 45, 46, 47, 48, 49}\\
  Then the input pattern\\
  \exindent{\tt [a, b, c] repeat 2 at 'c'}\\
  would yield the bindings\\
  \exindent{\tt a = [31, 34], b = [32, 35], c = [33, 36]}
\end{example}

\index{at*@\kwAtN}
\index{all@\kwAll}
\index{any@\kwAny}
\index{channel selector!multichannel}
\index{multichannel channel selector}

\paragraph{Multichannel channel selectors.} \Cal provides three
\sidenote{different ways to determine channel set}constructs for
selecting tokens from more than one channel of a multiport at the same
time. They are distinguished by the keyword that introduces them:
\kwAtN, \kwAny, \kwAll. They differ in the way they determine the set
of channels to read from as follows:
\begin{enumerate}
\item Following the \kwAtN-keyword is an expression that computes a
  (possibly empty) collection of channel identifiers.
\item The \kwAny-keyword results in those channels being read from
  that have a sufficient number of tokens available to be bound to the
  variables of the pattern---which could be none at all, in which case
  the set of channels would be empty.
\item The \kwAll-keyword selects all channels of the multiport.
\end{enumerate}

\index{input pattern!homogeneous use}
\index{homogeneous use!of input pattern}
\index{Map@{\tt Map} (type)}

All multichannel input patterns have in common that they are applied
{\em homogeneously}, i.e. the same number of tokens is read from all
selected channels (and no tokens are read from any of the other
channels). The variables are bound to {\em maps}---the keys of these
maps are channel identifiers, while the values are, depending on the
absence or presence of a repeat-clause, either tokens or lists of
tokens. Fig. \ref{fig:TokenVarTypes} gives the static types of the
pattern variables for multichannel patterns.

\index{example!multichannel input patterns}
\begin{example}[Multichannel input patterns]
  Assume four input channels {\tt 'a'}, {\tt 'b'}, {\tt 'c'}, {\tt 'd'} with the following input tokens:\\
  \exindent{\tt 'a': 11, 12, 13, 14, 15, 16, 17, 18, 19}\\
  \exindent{\tt 'b': 21, 22, 23, 24, 25}\\
  \exindent{\tt 'c': 31, 32, 33, 34, 35, 36, 37, 38, 39}\\
  \exindent{\tt 'd': 41, 42, 43}

  The input pattern\\
  \exindent{\tt [a, b, c] at* \{'a', 'c'\}}\\
  yields the bindings\\
  \exindent{\tt a = map\{'a'->11, 'c'->31\}}\\
  \exindent{\tt b = map\{'a'->12, 'c'->32\}}\\
  \exindent{\tt c = map\{'a'->13, 'c'->33\}}

  The input pattern \\
  \exindent{\tt [a, b] all}\\
  results in the bindings\\
  \exindent{\tt a = map\{'a'->11, 'b'->21, 'c'->31, 'd'->41\}}\\
  \exindent{\tt b = map\{'a'->12, 'b'->22, 'c'->32, 'd'->42\}}\\
  In this case, the keyword \kwAny~instead of \kwAll~would have
  produced the same result.

  The input pattern \\
  \exindent{\tt [a, b] repeat 2 any}\\
  results in the bindings\\
  \exindent{\tt a = map\{'a'->[11, 13], 'b'->[21, 23], 'c'->[31,
    33]\}}\\
  \exindent{\tt b = map\{'a'->[12, 14], 'b'->[22, 24], 'c'->[32,
    34]\}}\\
  In this case, \kwAll~instead of \kwAny~would not have worked,
  because the channel {\tt 'd'} does not provide the required number
  of tokens.
\end{example}

\index{input pattern!multiport|)}
\index{multiport input pattern|)}


\subsection{Scoping of action variables}

\index{action!variable!scope|(}
\index{action!scope|(}
\index{variable!scoping!in actions|(}
\index{pattern variable!scoping|(}


The
scope of the variables inside the input patterns, as well as the
explicitly declared variables in the var-clause of an action is the
entire action---as a consequence, these variables can depend on each
other. The general scoping rules from \sidenote{pattern variables $\leftrightarrow$ \kwVar-variables}section
\ref{sect:VariableScoping} need to be adapted in order to properly
handle this situation.

\index{input pattern!variable!dependencies}
\index{pattern variable!dependencies}
\index{repeat-clause!expression!free variables of}
\index{channel selector!free variables of}

In particular, input pattern variables do not have any initialization
expression that would make them depend explicitly on any other
\sidenote{$F_v$ for pattern variables \\$\To$
  \ref{sect:VariableScoping}, Def. \ref{def:DependencySets}}variable.
However, their values clearly depend on the expressions in the
repeat-clause and the channel selector (if present). For this reason,
for any input pattern variable $v$, we define the set of free
variables of its initialization expression $F_v$ to be the union of
the free variables of the corresponding expressions in the
repeat-clause and the channel selector.

The permissible dependencies then follow from the rules in section
\ref{sect:VariableScoping}.

\index{example!action variable scope}
\begin{example}[Action variable scope]
  The following action skeleton contains dependencies between input
  pattern variables and explicitly declared variables
\begin{alltt}    [n] at c, [k], [a] repeat m * n ==> ...
    var
        m = k * k, c = f(m)
    do ... end
\end{alltt}
  These declarations are well-formed, because the variables can be
  evaluated in the order {\tt k}, {\tt m}, {\tt c}, {\tt n}, {\tt a}.

  By contrast, the following action heads create {\bf circular
    dependencies} and are therefore {\bf errors}:
\begin{alltt}    [n] at f(a), [a] repeat n ==> ... do ... end

    [a] repeat a[0] + 1 ==> ... do ... end

    [a] repeat n ==> ...
    var
        n = f(b), b = sum(a)
    do ... end

    [a] at c, [b] repeat a ==> ...
    var 
        c = g(b)
    do ... end
\end{alltt}
\end{example}

\index{action!variable!scope|)}
\index{action!scope|)}
\index{variable!scoping!in actions|)}
\index{pattern variable!scoping|)}

\index{input pattern|)}


\section{Output expressions}\label{sect:OutputExpressions}

\index{output expression|(}

\sidenote{output expressions dual of input patterns}Output expressions
are conceptually the dual notion to input patterns---they are
syntactically similar, but rather than containing a list of variable
names which get bound to input tokens they contain a list of
expressions that computes the output tokens, the so-called {\em token
  expressions}.


\index{repeat@\kwRepeat}
\index{at@\kwAt}
\index{at*@\kwAtN}
\index{any@\kwAny}
\index{all@\kwAll}
\index{[...]@{\tt [...]}!in output expression}
\index{:@{\tt :}!in output expression}

\bgr
OutputExpression : [ID~'\charColon'] ~'['~Expressions~']'~[RepeatClause]~[ChannelSelector].

ChannelSelector : \kwAt~Expression ;
     | \kwAtN~Expression ; 
     | [\kwAtN]~\kwAny~;
     | [\kwAtN]~\kwAll.

RepeatClause : \kwRepeat~Expression.
\egr

\index{repeat-clause!in output expression}
\index{channel selector!in output expression}

The repeat-clause and channel selector work not unlike in the case of
input patterns, but with one crucial difference. For input patterns,
these constructs control the {\em construction} of a data structure
that was assembled from input tokens and then bound the pattern
variables. In the case out output expressions, the values computed by
the token expressions \sidenote{deconstructing output expression
  values}are themselves these data structures, and they are
indexed into according to the repeat-clause and the channel selector,
if these are present.

\begin{table}[t]
\center{
\begin{tabular}{|r|c|c|}\hline
     & no repeat-clause & with repeat-clause \\ \hline\hline
single channel & {\tt T} & {\tt Seq[T]} \\ \hline
multichannel & {\tt Map[CID, T]} & {\tt Map[CID, Seq[T]]} \\ \hline
\end{tabular}
}
\caption{Token expression types depending on output expression kind
  and presence of a repeat-clause. ({\tt T} is the token type of the
  corresponding output port.)}\label{fig:OutputExprTypes}

\index{token expression!table@table (Fig. \ref{fig:OutputExprTypes})}
\index{output expression!token expression!type, table@type, table (Fig. \ref{fig:OutputExprTypes})}
\end{table}


\index{repeat-clause!in output expression}
\index{channel selector!in output expression}
\index{token expression!type of}

The table in Fig. \ref{fig:OutputExprTypes} shows the kind of data
structure a token expression has to evaluate to depending on the
presence or absence of a repeat-clause, and depending on whether the
output expression is a single-channel or a multichannel output
expression.

\index{output expression!single-channel}
\index{single-channel output expression}
\index{repeat-clause}
\index{channel selector!single-channel}
\index{single-channel channel selector}

\paragraph{Single-channel output expressions.} 
In single-channel output expressions without repeat-clause, the token
expressions represent the output tokens directly, and the number of
output tokens produced is equal to the number of token expressions. If
a single-channel output expression does have a repeat-clause, the
token expressions must evaluate to sequences of tokens, and the number
\sidenote{repeat-clause: lists must be long enough!}of tokens produced
is the product of the number of token expressions and the value of the
repeat-expression. In addition, the value of the repeat-expression is
the minimum number of tokens each of the sequences must contain.

\index{example!single-channel output expression}
\begin{example}[Single-channel output expressions.]
  The output expression\\
  \exindent{\tt ... ==> [1, 2, 3]}\\
  produces the output tokens {\tt 1, 2, 3}.

  The output expression\\
  \exindent{\tt ... ==> [[1, 2, 3], [4, 5], [6, 7, 8]] repeat 2}\\
  produces the output tokens {\tt 1, 4, 6, 2, 5, 7}.

  The output expression\\
  \exindent{\tt ... ==> [[1, 2, 3], [4, 5]] repeat 1 at 'b'}\\
  produces the output tokens {\tt 1, 4} on channel {\tt 'b'}.
\end{example}

\index{rationale!output expression design}
\begin{rationale}
  One of the key reasons for interpreting the repeat-construct in
  output expressions as described above is to maintain
  symmetry with the way input patterns are handled. For instance,
  consider the following action:

  {\tt action [a, b, c] repeat k ==> [a, b, c] repeat k end}

  This action copies its input tokens identically to its output, $3k$
  tokens at a time. It is, therefore, equivalent to the action

  {\tt action [a] repeat 3 * k ==> [a] repeat 3 * k end}
  
  The same rationale applies to multichannel output expressions, see
  below. Here, too, the design strives for a symmetry between the
  input patterns and output expressions, as far as their fundamental
  directedness allows (the former declares variables, while the latter
  uses them to compute values).
\end{rationale}

\index{output expression!multichannel}
\index{multichannel output expression}
\index{repeat-clause}
\index{channel selector!multichannel}
\index{multichannel channel selector}
\index{channel selector!output expression!constraints on map domains}
\index{Map@{\tt Map} (type)}

\paragraph{Multichannel output expressions.}
Similarly, for multichannel output expressions without a repeat
\sidenote{channel selector constrains token map domains}expression,
the token expressions must evaluate to maps from channel identifiers
to tokens. If a repeat-clause is present, the maps must map channel
identifiers to sequences of tokens, the number of elements on those
sequences being not smaller than the value of the repeat expression.
The channel selector places some constraints on the domains of the
maps as follows:
\begin{itemize}
\item For an \kwAtN~channel selector, the intersection of the domains
  of the maps must contain the collection of channel identifiers the
  selector expression evaluates to.
\item For an \kwAll~channel selector, the intersection of all domains
  must contain the set of all channel identifiers currently valid for
  the corresponding port.
\item For a \kwAny~channel selector, no constraints apply to the
  domains. The channels that output will be produced on are those in
  the intersection of all domains, which may be empty.
\end{itemize}

\index{output pattern!homogeneous use}
\index{homogeneous use!of output pattern}

\sidenote{homogeneous output production}These rules are designed to
make it possible to produce output {\em homogeneously} on all selected
output channels---in other words, all output channels of a multiport
output the same number of tokens if they output any tokens at all.

\begin{example}[Multichannel output expressions.]
  The output expression
  \begin{alltt}   ... ==> [map \{'a'->1, 'b'->2\},
            map \{'a'->3, 'b'->4,'c'->5\}] at* \{'a', 'b'\} \end{alltt}  
  produces the following output on the channels {\tt 'a'} and {\tt
      'b'}:\\
  \exindent{\tt a: 1, 3}\\
  \exindent{\tt b: 2, 4}\\
  Nothing is output on channel {\tt 'c'}.

  The output expression
  \begin{alltt}   ... ==> [map \{'a'->[1, 2], 'b'->[3, 4]\}, 
            map \{'a'->[5, 6], 'b'->[7, 8]\}] 
            repeat 2 at* \{'a', 'b'\} \end{alltt} 
  results in the following output:\\
  \exindent{\tt a: 1, 5, 2, 6}\\
  \exindent{\tt b: 3, 7, 4, 8}
\end{example}

\index{output expression|)}


\section{Delays} \label{sect:Delays}

\index{action!delay|(}
\index{delay!of action|(}

\index{delay@\kwDelay}

The expression following the \kwDelay-keyword specifies the delay of
the action.\sidenote{uninterpreted delays} The actor language itself
does not attach any meaning to this information, other than that it is
part of the label of a state transition of an actor. See
section \ref{sect:Time} for some more information on time inside the
\Cal language.

If the actor contains a time-clause, then the static type of each
delay expression must be a subtype of the type specified in that
time-clause.

\index{action!delay|)}
\index{delay!of action|)}



\section{On action selection: guards and other activation
  conditions}\label{sect:ActionSelection}

\index{action!selection|(}

\index{action!activated}
\index{action!activation conditions}
\index{activation conditions!of action}

At any given point during the execution of an actor, an action may
potentially fire on some input data. Whether it is {\em activated},
\sidenote{activation conditions}i.e. whether in a given situation it
actually can fire, depends on whether its {\em activation conditions}
have all been met. The minimal conditions are as follows:
\begin{enumerate}
\item According to the action schedule (see section
  \ref{sect:ActionSchedules}) this action may fire next, according to
  Def. \ref{def:LAS} on page \pageref{def:LAS}.
\item No higher-priority action is activated (see section
  \ref{sect:ActionPriorities}).
\item There are sufficient input tokens available to bind the input
  pattern variables to appropriate values.
\item Given such a binding, all guard expressions (which must be {\tt
    Boolean} expressions) evaluate to \kwTrue.
\item There is sufficient room for the output tokens produced by this
  firing.
\end{enumerate}

Depending on the context in which the actor is embedded, additional
conditions for activating actions may apply. A model of computation
may reject an actor as non-well-formed if it cannot statically
ascertain that
it will meet the relevant activation conditions whenever it needs to.

\sidenote{additional conditions by model of computation}

\index{implementation note!output token activation condition}
\begin{implementation}
  The last activation condition may not be easily satisfiable in the
  general case, as it may be unknown exactly how many output tokens a
  firing will produce until it has executed and the output tokens have
  been computed. The important point is that firing an actor has to
  appear to the outside as an atomic step---the physical time it takes
  is not directly relevant, and the execution may even stall due to
  a lack of space for the output tokens, but it is imperative that the
  firing looks as if it occurred in one atomic transition.
\end{implementation}

\index{action!selection|)}


\section{Initialization actions}\label{sect:InitActions}

\index{action!initialization action|(}
\index{initialization action|(}


\sidenote{special action:\\no input, no invariants}Initialization
actions are executed at the beginning of an actor's life cycle. They
are very similar to regular actions, with two important differences:
\begin{enumerate}
\item Since the assumption is that at the beginning of an actor
  execution no input is available, initialization actions have no
  input patterns. They may produce output, however.
\item With the exception of initialization expressions in variable
  declarations, an initialization action contains the first code to be
  executed inside the actor. Any state invariants in the actor may not
  hold, and instead have to be established by the initialization action.
\end{enumerate}

The syntax of initialization actions is as follows:

\index{:@{\tt :}!in initialization action}
\index{initialize@\kwInitialize}
\index{do@\kwDo}
\index{end@\kwEnd}
\index{endinitialize@\kwEndInitialize}
\index{==>@{\tt ==>}!in initialization action}
\index{guard@\kwGuard}
\index{var@\kwVar}
\index{delay@\kwDelay}

\bgr
InitializationAction : [ActionTag '\charColon'] ;
    \kwInitialize~ InitializerHead ~[\kwDo ~Statements]~ (\kwEnd|\kwEndInitialize).

InitializerHead : '==\charMore'~OutputExpressions;
             [\kwGuard~Expressions ] ~[\kwVar~VarDecls ] ~[\kwDelay ~Expression].
\egr

\index{activation conditions!of initialization action}
\index{action!initialization action!activation conditions}
\index{initialization action!activation conditions}

\sidenote{activation conditions}The activation conditions for actions
apply also to initialization actions---of course, since there is no
input, the conditions concerning input tokens become vacuously true.

\index{action!initialization action!multiple activated}
\index{initialization action!multiple activated}
\pagebreak[4]

If an actor has more
than one initialization action, and if more than one is activated at
the beginning of an actor execution, one of them is chosen \sidenote{only one init action gets fired}
arbitrarily. The actor context can of course make than choice.


\index{action!initialization action|)}
\index{initialization action|)}


\index{action|)}



% Local Variables:
% TeX-master: "../reference"
% End:
