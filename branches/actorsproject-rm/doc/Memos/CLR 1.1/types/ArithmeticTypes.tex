\section{Arithmetic types}

Arithmetic types contain (representations of) numbers. We distinguish
between integral types representing integers,
fixed point types representing fixed-precision rational numbers, and
floating point types, representing variable precision rational
numbers.

The system of arithmetic types was designed with two central
objectives in mind, resulting from the fact that it needs to cater to
both hardware designers and software programmers.
\begin{enumerate}
\item It must behave similar to familiar systems of arithmetic types
  known from the C or Java programming languages.
\item It must provide programmer control over the size of number
  representations, specifically for the integral types, and be able to
  perform safe type inference over them.
\end{enumerate}
These two goals can be in conflict with one another---while a C
programmer using the {\tt int} datatype expects the addition of two
32-bit numbers to yield another 32-bit number, possibly causing an
overflow for very large or small values, a hardware designer wants to
be able to capture a 33-bit result and continue to compute with it,
until an explicit decision is made to eliminate superfluous bits.

\subsection{Integral types}

All integral types may contain a parameter {\tt size} describing the
size of the representation in bits, and thus bounding the range of
values that can be instances of that type. An integral type with a
{\tt size} parameter, whether explicit or implicit by default, is
called {\em bounded}. Bounded unsigned integral types range from 0 to
$2^N-1$, where $N$ is the value of the {\tt size} parameter. Bounded
signed integral types range from $-2^{N-1}$ to $2^{N-1}-1$.

Integral type {\em classes} fall into two categories---the {\tt
  integer} type class, and the {\em limited} type classes.

\subsubsection{\tt integer}

The {\tt integer} type class can be used to build arbitrarily large
(signed) integral types. It permits any non-negative integral value as its {\tt
  size} parameter. If that parameter is absent, the value range of the
type is unbounded.

As a result of this flexibility, some implementation targets---notably
hardware implementations---may not support the use of unbounded {\tt
  integer} data types.

\subsubsection{Limited integral types}\label{sect:LimitedIntegralTypes}

Limited integral type classes set an upper limit to the permissable
values for their {\tt size} parameter. This value, the {\em bit limit}
depends on the type class, and is also the default value for the {\tt
  size} parameter if left unspecified. The table below lists the type
classes of limited integral types, along with their respective bit
limits and an indication of whether they are signed.

\begin{center}
\begin{tabular}{c|c|c}
type class   &   bit limit  &  signed \\ \hline \hline
{\tt byte}   &   8          &  N      \\ \hline
{\tt short}  &   16         &  Y      \\ \hline
{\tt ushort} &   16         &  N      \\ \hline
{\tt int}    &   32         &  Y      \\ \hline
{\tt uint}   &   32         &  N      \\ \hline
{\tt long}   &   64         &  Y      \\ \hline
{\tt ulong}  &   64         &  N      \\ \hline
\end{tabular}
\end{center}

The defaulting rule implies that, for instance, the type {\tt short}
is the same as the type {\tt short(size=16)}. 

We say that an integral type class is {\em larger} than another if it
has a greater bit limit. Note that this does not necessarily translate
to the types constructed from these type classes---a {\tt byte} is a
"larger" type than a {\tt uint(size=6)}, even though {\tt uint} is a
larger type class than {\tt byte}.

\subsubsection{Integral type promotion}

In order to perform type inference on expressions involving integral
types, operators frequently need to be promoted from one type to
another. For instance, the general rule for inferring the type of the
result of an addition of two values of bounded types {\tt T(size=a)}
and {\tt T(size=b)} is that the result is of type {\tt T(size=c)} with
\[c = \min(\max(a, b) + 1, L)\] and $L$ being the bit limit of {\tt
  T}. However, this rule assumes that the type of both operands is of
the same type class, which it may not be---if {\tt v} is of type {\tt
  int(size=9)} and {\tt w} is of type {\tt short}, what is the type of
{\tt v + w}?

In order to avoid having to specify for each operator a complex set of
rules covering all combinations of integral type classes, there is a
simple set of general integral type "promotion" rules that establish a
straightforward subtype relationship between integral types and allow
us to use simple rules such as the one above for type inference.

The rules are as follows:
\begin{enumerate}
\item Every signed integral type {\tt T(size=a)} is a subtype of every
  {\tt S(size=a)} for any signed integral type class S that is larger
  than T.
\item Every unsigned integral type {\tt T(size=a)} is a subtype of every
  {\tt S(size=a)} for any unsigned integral type class S that is larger
  than T.
\item Every unsigned integral type {\tt T(size=a)} is a subtype of
  every {\tt S(size=a+1)} for every signed integral type class S whose
  bit limit is $\geq a+1$.
\end{enumerate}

Examples:
\begin{enumerate}
\item {\tt short(size=14)} is a subtype of {\tt int(size=14)} and {\tt
    long(size=14)}.
\item {\tt ushort(size=14)} is a subtype of {\tt uint(size=14)} and
  {\tt ulong(size=14)}.
\item {\tt ushort(size=14)} is a subtype of {\tt short(size=15)}.
  However, {\tt ushort(size=16)} is {\bf not} a subtype of {\tt
    short(size=17)} (which does not exist), although it is a subtype
  of {\tt int(size=17)}.
\end{enumerate}

With these rules, we can determine the type of adding an {\tt
  int(size=9)} to a {\tt short} as follows. {\tt short} is really {\tt
  short(size=16)}, which according to the first promotion rule is a
subtype of {\tt int(size=16)}. Adding this to an {\tt int(size=9)}
results in an {\tt int(size=17)}, according to the rule for the add
operator described above.


\subsection{Fixed point types}

There are currently no fixed-point types defined. This is going to change.

\subsection{Floating-point types}

Currently, the type of double-precision floating point numbers is {\tt real}.

%\section{Complex arithmetic types}

%Are we going to add complex numbers to our basic type system?




% Local Variables:
% TeX-master: "TypeSystem"
% End:

